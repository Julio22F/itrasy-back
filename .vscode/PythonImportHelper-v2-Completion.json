[
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "django.contrib.auth.models",
        "description": "django.contrib.auth.models",
        "isExtraImport": true,
        "detail": "django.contrib.auth.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "django.contrib.auth.models",
        "description": "django.contrib.auth.models",
        "isExtraImport": true,
        "detail": "django.contrib.auth.models",
        "documentation": {}
    },
    {
        "label": "User",
        "importPath": "django.contrib.auth.models",
        "description": "django.contrib.auth.models",
        "isExtraImport": true,
        "detail": "django.contrib.auth.models",
        "documentation": {}
    },
    {
        "label": "authenticate",
        "importPath": "django.contrib.auth",
        "description": "django.contrib.auth",
        "isExtraImport": true,
        "detail": "django.contrib.auth",
        "documentation": {}
    },
    {
        "label": "get_user_model",
        "importPath": "django.contrib.auth",
        "description": "django.contrib.auth",
        "isExtraImport": true,
        "detail": "django.contrib.auth",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "django.contrib.auth",
        "description": "django.contrib.auth",
        "isExtraImport": true,
        "detail": "django.contrib.auth",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "django.contrib.auth",
        "description": "django.contrib.auth",
        "isExtraImport": true,
        "detail": "django.contrib.auth",
        "documentation": {}
    },
    {
        "label": "get_user_model",
        "importPath": "django.contrib.auth",
        "description": "django.contrib.auth",
        "isExtraImport": true,
        "detail": "django.contrib.auth",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "timegm",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "timegm",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "day_abbr",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "day_name",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "month_abbr",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "month_name",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "permissions",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "serializers",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "permissions",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "serializers",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "rest_framework",
        "description": "rest_framework",
        "isExtraImport": true,
        "detail": "rest_framework",
        "documentation": {}
    },
    {
        "label": "smart_str",
        "importPath": "django.utils.encoding",
        "description": "django.utils.encoding",
        "isExtraImport": true,
        "detail": "django.utils.encoding",
        "documentation": {}
    },
    {
        "label": "smart_str",
        "importPath": "django.utils.encoding",
        "description": "django.utils.encoding",
        "isExtraImport": true,
        "detail": "django.utils.encoding",
        "documentation": {}
    },
    {
        "label": "BaseAuthentication",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "get_authorization_header",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "BaseAuthentication",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "get_authorization_header",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "BasicAuthentication",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "get_authorization_header",
        "importPath": "rest_framework.authentication",
        "description": "rest_framework.authentication",
        "isExtraImport": true,
        "detail": "rest_framework.authentication",
        "documentation": {}
    },
    {
        "label": "gettext_lazy",
        "importPath": "django.utils.translation",
        "description": "django.utils.translation",
        "isExtraImport": true,
        "detail": "django.utils.translation",
        "documentation": {}
    },
    {
        "label": "gettext_lazy",
        "importPath": "django.utils.translation",
        "description": "django.utils.translation",
        "isExtraImport": true,
        "detail": "django.utils.translation",
        "documentation": {}
    },
    {
        "label": "gettext_lazy",
        "importPath": "django.utils.translation",
        "description": "django.utils.translation",
        "isExtraImport": true,
        "detail": "django.utils.translation",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "Member",
        "importPath": "member.models",
        "description": "member.models",
        "isExtraImport": true,
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "MemberSerializer",
        "importPath": "member.serializers",
        "description": "member.serializers",
        "isExtraImport": true,
        "detail": "member.serializers",
        "documentation": {}
    },
    {
        "label": "MemberSerializer",
        "importPath": "member.serializers",
        "description": "member.serializers",
        "isExtraImport": true,
        "detail": "member.serializers",
        "documentation": {}
    },
    {
        "label": "AuthenticationFailed",
        "importPath": "rest_framework.exceptions",
        "description": "rest_framework.exceptions",
        "isExtraImport": true,
        "detail": "rest_framework.exceptions",
        "documentation": {}
    },
    {
        "label": "AuthenticationFailed",
        "importPath": "rest_framework.exceptions",
        "description": "rest_framework.exceptions",
        "isExtraImport": true,
        "detail": "rest_framework.exceptions",
        "documentation": {}
    },
    {
        "label": "FieldDoesNotExist",
        "importPath": "django.core.exceptions",
        "description": "django.core.exceptions",
        "isExtraImport": true,
        "detail": "django.core.exceptions",
        "documentation": {}
    },
    {
        "label": "ObjectDoesNotExist",
        "importPath": "django.core.exceptions",
        "description": "django.core.exceptions",
        "isExtraImport": true,
        "detail": "django.core.exceptions",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "migrations",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "re_path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "include",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "get_resolver",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "format_suffix_patterns",
        "importPath": "rest_framework.urlpatterns",
        "description": "rest_framework.urlpatterns",
        "isExtraImport": true,
        "detail": "rest_framework.urlpatterns",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "rest_framework.response",
        "description": "rest_framework.response",
        "isExtraImport": true,
        "detail": "rest_framework.response",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "rest_framework.response",
        "description": "rest_framework.response",
        "isExtraImport": true,
        "detail": "rest_framework.response",
        "documentation": {}
    },
    {
        "label": "APIView",
        "importPath": "rest_framework.views",
        "description": "rest_framework.views",
        "isExtraImport": true,
        "detail": "rest_framework.views",
        "documentation": {}
    },
    {
        "label": "APIView",
        "importPath": "rest_framework.views",
        "description": "rest_framework.views",
        "isExtraImport": true,
        "detail": "rest_framework.views",
        "documentation": {}
    },
    {
        "label": "exception_handler",
        "importPath": "rest_framework.views",
        "description": "rest_framework.views",
        "isExtraImport": true,
        "detail": "rest_framework.views",
        "documentation": {}
    },
    {
        "label": "swagger_auto_schema",
        "importPath": "drf_yasg.utils",
        "description": "drf_yasg.utils",
        "isExtraImport": true,
        "detail": "drf_yasg.utils",
        "documentation": {}
    },
    {
        "label": "swagger_auto_schema",
        "importPath": "drf_yasg.utils",
        "description": "drf_yasg.utils",
        "isExtraImport": true,
        "detail": "drf_yasg.utils",
        "documentation": {}
    },
    {
        "label": "send_email",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "send_email_password_reset",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "send_email_reset",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "send_password_reset",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "urls",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "forget_password_urls",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "change_user_info_urls",
        "importPath": "email_verification",
        "description": "email_verification",
        "isExtraImport": true,
        "detail": "email_verification",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "lib.loguru",
        "description": "lib.loguru",
        "isExtraImport": true,
        "detail": "lib.loguru",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "isExtraImport": true,
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "environ",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "get_asgi_application",
        "importPath": "django.core.asgi",
        "description": "django.core.asgi",
        "isExtraImport": true,
        "detail": "django.core.asgi",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "decouple",
        "description": "decouple",
        "isExtraImport": true,
        "detail": "decouple",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "decouple",
        "description": "decouple",
        "isExtraImport": true,
        "detail": "decouple",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "decouple",
        "description": "decouple",
        "isExtraImport": true,
        "detail": "decouple",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "django.conf",
        "description": "django.conf",
        "isExtraImport": true,
        "detail": "django.conf",
        "documentation": {}
    },
    {
        "label": "include",
        "importPath": "django.conf.urls",
        "description": "django.conf.urls",
        "isExtraImport": true,
        "detail": "django.conf.urls",
        "documentation": {}
    },
    {
        "label": "include",
        "importPath": "django.conf.urls",
        "description": "django.conf.urls",
        "isExtraImport": true,
        "detail": "django.conf.urls",
        "documentation": {}
    },
    {
        "label": "static",
        "importPath": "django.conf.urls.static",
        "description": "django.conf.urls.static",
        "isExtraImport": true,
        "detail": "django.conf.urls.static",
        "documentation": {}
    },
    {
        "label": "serve",
        "importPath": "django.conf.urls.static",
        "description": "django.conf.urls.static",
        "isExtraImport": true,
        "detail": "django.conf.urls.static",
        "documentation": {}
    },
    {
        "label": "get_schema_view",
        "importPath": "drf_yasg.views",
        "description": "drf_yasg.views",
        "isExtraImport": true,
        "detail": "drf_yasg.views",
        "documentation": {}
    },
    {
        "label": "openapi",
        "importPath": "drf_yasg",
        "description": "drf_yasg",
        "isExtraImport": true,
        "detail": "drf_yasg",
        "documentation": {}
    },
    {
        "label": "openapi",
        "importPath": "drf_yasg",
        "description": "drf_yasg",
        "isExtraImport": true,
        "detail": "drf_yasg",
        "documentation": {}
    },
    {
        "label": "openapi",
        "importPath": "drf_yasg",
        "description": "drf_yasg",
        "isExtraImport": true,
        "detail": "drf_yasg",
        "documentation": {}
    },
    {
        "label": "views",
        "importPath": "rest_framework.authtoken",
        "description": "rest_framework.authtoken",
        "isExtraImport": true,
        "detail": "rest_framework.authtoken",
        "documentation": {}
    },
    {
        "label": "get_wsgi_application",
        "importPath": "django.core.wsgi",
        "description": "django.core.wsgi",
        "isExtraImport": true,
        "detail": "django.core.wsgi",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "localtime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "strftime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "render_to_string",
        "importPath": "django.template.loader",
        "description": "django.template.loader",
        "isExtraImport": true,
        "detail": "django.template.loader",
        "documentation": {}
    },
    {
        "label": "render_to_string",
        "importPath": "django.template.loader",
        "description": "django.template.loader",
        "isExtraImport": true,
        "detail": "django.template.loader",
        "documentation": {}
    },
    {
        "label": "render_to_string",
        "importPath": "django.template.loader",
        "description": "django.template.loader",
        "isExtraImport": true,
        "detail": "django.template.loader",
        "documentation": {}
    },
    {
        "label": "get_template",
        "importPath": "django.template.loader",
        "description": "django.template.loader",
        "isExtraImport": true,
        "detail": "django.template.loader",
        "documentation": {}
    },
    {
        "label": "int_to_base36",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "base36_to_int",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "base36_to_int",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "int_to_base36",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "urlsafe_base64_decode",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "urlsafe_base64_encode",
        "importPath": "django.utils.http",
        "description": "django.utils.http",
        "isExtraImport": true,
        "detail": "django.utils.http",
        "documentation": {}
    },
    {
        "label": "urls",
        "importPath": "django_email_verification",
        "description": "django_email_verification",
        "isExtraImport": true,
        "detail": "django_email_verification",
        "documentation": {}
    },
    {
        "label": "forms",
        "importPath": "django",
        "description": "django",
        "isExtraImport": true,
        "detail": "django",
        "documentation": {}
    },
    {
        "label": "forms",
        "importPath": "django",
        "description": "django",
        "isExtraImport": true,
        "detail": "django",
        "documentation": {}
    },
    {
        "label": "forms",
        "importPath": "django",
        "description": "django",
        "isExtraImport": true,
        "detail": "django",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "current_thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Lock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "EmailMultiAlternatives",
        "importPath": "django.core.mail",
        "description": "django.core.mail",
        "isExtraImport": true,
        "detail": "django.core.mail",
        "documentation": {}
    },
    {
        "label": "send_mail",
        "importPath": "django.core.mail",
        "description": "django.core.mail",
        "isExtraImport": true,
        "detail": "django.core.mail",
        "documentation": {}
    },
    {
        "label": "send_mail",
        "importPath": "django.core.mail",
        "description": "django.core.mail",
        "isExtraImport": true,
        "detail": "django.core.mail",
        "documentation": {}
    },
    {
        "label": "EmailMessage",
        "importPath": "django.core.mail",
        "description": "django.core.mail",
        "isExtraImport": true,
        "detail": "django.core.mail",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "django.utils",
        "description": "django.utils",
        "isExtraImport": true,
        "detail": "django.utils",
        "documentation": {}
    },
    {
        "label": "smtplib,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "smtplib.",
        "description": "smtplib.",
        "detail": "smtplib.",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEMultipart",
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "isExtraImport": true,
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "MIMEMultipart",
        "importPath": "email.mime.multipart",
        "description": "email.mime.multipart",
        "isExtraImport": true,
        "detail": "email.mime.multipart",
        "documentation": {}
    },
    {
        "label": "constant_time_compare",
        "importPath": "django.utils.crypto",
        "description": "django.utils.crypto",
        "isExtraImport": true,
        "detail": "django.utils.crypto",
        "documentation": {}
    },
    {
        "label": "salted_hmac",
        "importPath": "django.utils.crypto",
        "description": "django.utils.crypto",
        "isExtraImport": true,
        "detail": "django.utils.crypto",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exc_info",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "iscoroutinefunction",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isgeneratorfunction",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "keyword",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyword",
        "description": "keyword",
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "linecache",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "linecache",
        "description": "linecache",
        "detail": "linecache",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tokenize",
        "description": "tokenize",
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "Formatter",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "decimal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "decimal",
        "description": "decimal",
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "current_process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "basename",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "splitext",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "handle_log",
        "importPath": "lib.discord.report",
        "description": "lib.discord.report",
        "isExtraImport": true,
        "detail": "lib.discord.report",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ImageTk",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageTk",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageTk",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "style",
        "description": "style",
        "isExtraImport": true,
        "detail": "style",
        "documentation": {}
    },
    {
        "label": "CustomWindow",
        "importPath": "custom_window",
        "description": "custom_window",
        "isExtraImport": true,
        "detail": "custom_window",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "random",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "unidecode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unidecode",
        "description": "unidecode",
        "detail": "unidecode",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "boto3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "boto3",
        "description": "boto3",
        "detail": "boto3",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "NoCredentialsError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "upload_optimized_files",
        "importPath": "aws",
        "description": "aws",
        "isExtraImport": true,
        "detail": "aws",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "bpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bpy",
        "description": "bpy",
        "detail": "bpy",
        "documentation": {}
    },
    {
        "label": "mathutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mathutils",
        "description": "mathutils",
        "detail": "mathutils",
        "documentation": {}
    },
    {
        "label": "Vector",
        "importPath": "mathutils",
        "description": "mathutils",
        "isExtraImport": true,
        "detail": "mathutils",
        "documentation": {}
    },
    {
        "label": "Vector",
        "importPath": "mathutils",
        "description": "mathutils",
        "isExtraImport": true,
        "detail": "mathutils",
        "documentation": {}
    },
    {
        "label": "Matrix",
        "importPath": "mathutils",
        "description": "mathutils",
        "isExtraImport": true,
        "detail": "mathutils",
        "documentation": {}
    },
    {
        "label": "bmesh",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bmesh",
        "description": "bmesh",
        "detail": "bmesh",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "mathutils.kdtree",
        "description": "mathutils.kdtree",
        "isExtraImport": true,
        "detail": "mathutils.kdtree",
        "documentation": {}
    },
    {
        "label": "BVHTree",
        "importPath": "mathutils.bvhtree",
        "description": "mathutils.bvhtree",
        "isExtraImport": true,
        "detail": "mathutils.bvhtree",
        "documentation": {}
    },
    {
        "label": "bpy,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bpy.",
        "description": "bpy.",
        "detail": "bpy.",
        "documentation": {}
    },
    {
        "label": "msgpack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "msgpack",
        "description": "msgpack",
        "detail": "msgpack",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "collect_data_files",
        "importPath": "PyInstaller.utils.hooks",
        "description": "PyInstaller.utils.hooks",
        "isExtraImport": true,
        "detail": "PyInstaller.utils.hooks",
        "documentation": {}
    },
    {
        "label": "collect_dynamic_libs",
        "importPath": "PyInstaller.utils.hooks",
        "description": "PyInstaller.utils.hooks",
        "isExtraImport": true,
        "detail": "PyInstaller.utils.hooks",
        "documentation": {}
    },
    {
        "label": "generateOptimizedData",
        "importPath": "objsplit",
        "description": "objsplit",
        "isExtraImport": true,
        "detail": "objsplit",
        "documentation": {}
    },
    {
        "label": "pymeshlab",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pymeshlab",
        "description": "pymeshlab",
        "detail": "pymeshlab",
        "documentation": {}
    },
    {
        "label": "csv,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv.",
        "description": "csv.",
        "detail": "csv.",
        "documentation": {}
    },
    {
        "label": "pywavefront",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pywavefront",
        "description": "pywavefront",
        "detail": "pywavefront",
        "documentation": {}
    },
    {
        "label": "lib.optimize.bolton_analysis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lib.optimize.bolton_analysis",
        "description": "lib.optimize.bolton_analysis",
        "detail": "lib.optimize.bolton_analysis",
        "documentation": {}
    },
    {
        "label": "django.core.validators",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "django.core.validators",
        "description": "django.core.validators",
        "detail": "django.core.validators",
        "documentation": {}
    },
    {
        "label": "MinLengthValidator",
        "importPath": "django.core.validators",
        "description": "django.core.validators",
        "isExtraImport": true,
        "detail": "django.core.validators",
        "documentation": {}
    },
    {
        "label": "s3direct.fields",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "s3direct.fields",
        "description": "s3direct.fields",
        "detail": "s3direct.fields",
        "documentation": {}
    },
    {
        "label": "S3DirectField",
        "importPath": "s3direct.fields",
        "description": "s3direct.fields",
        "isExtraImport": true,
        "detail": "s3direct.fields",
        "documentation": {}
    },
    {
        "label": "ImportExportModelAdmin",
        "importPath": "import_export.admin",
        "description": "import_export.admin",
        "isExtraImport": true,
        "detail": "import_export.admin",
        "documentation": {}
    },
    {
        "label": "mark_safe",
        "importPath": "django.utils.safestring",
        "description": "django.utils.safestring",
        "isExtraImport": true,
        "detail": "django.utils.safestring",
        "documentation": {}
    },
    {
        "label": "Q",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Sum",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Max",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Q",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Q",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Subquery",
        "importPath": "django.db.models",
        "description": "django.db.models",
        "isExtraImport": true,
        "detail": "django.db.models",
        "documentation": {}
    },
    {
        "label": "Http404",
        "importPath": "django.http",
        "description": "django.http",
        "isExtraImport": true,
        "detail": "django.http",
        "documentation": {}
    },
    {
        "label": "FilterPagination",
        "importPath": "utils.pagination_utils",
        "description": "utils.pagination_utils",
        "isExtraImport": true,
        "detail": "utils.pagination_utils",
        "documentation": {}
    },
    {
        "label": "generate_password",
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "isExtraImport": true,
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "generate_api_key",
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "isExtraImport": true,
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_lab",
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "isExtraImport": true,
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_member",
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "isExtraImport": true,
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "importPath": "json.decoder",
        "description": "json.decoder",
        "isExtraImport": true,
        "detail": "json.decoder",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "MailTracking",
        "importPath": "mail_tracking.models",
        "description": "mail_tracking.models",
        "isExtraImport": true,
        "detail": "mail_tracking.models",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "message.models",
        "description": "message.models",
        "isExtraImport": true,
        "detail": "message.models",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "Activity",
        "importPath": "activity.models",
        "description": "activity.models",
        "isExtraImport": true,
        "detail": "activity.models",
        "documentation": {}
    },
    {
        "label": "Invoice",
        "importPath": "invoice.models",
        "description": "invoice.models",
        "isExtraImport": true,
        "detail": "invoice.models",
        "documentation": {}
    },
    {
        "label": "AFSetup",
        "importPath": "af_setup.models",
        "description": "af_setup.models",
        "isExtraImport": true,
        "detail": "af_setup.models",
        "documentation": {}
    },
    {
        "label": "EmailConfig",
        "importPath": "email_config.models",
        "description": "email_config.models",
        "isExtraImport": true,
        "detail": "email_config.models",
        "documentation": {}
    },
    {
        "label": "Retainer",
        "importPath": "patient.retainer.models",
        "description": "patient.retainer.models",
        "isExtraImport": true,
        "detail": "patient.retainer.models",
        "documentation": {}
    },
    {
        "label": "Trackingmore",
        "importPath": "trackingmore.models",
        "description": "trackingmore.models",
        "isExtraImport": true,
        "detail": "trackingmore.models",
        "documentation": {}
    },
    {
        "label": "DESCRIPTIONS_FOR_EACH_TYPE",
        "importPath": "utils.const_utils",
        "description": "utils.const_utils",
        "isExtraImport": true,
        "detail": "utils.const_utils",
        "documentation": {}
    },
    {
        "label": "Prescription",
        "importPath": "patient.prescription.models",
        "description": "patient.prescription.models",
        "isExtraImport": true,
        "detail": "patient.prescription.models",
        "documentation": {}
    },
    {
        "label": "capture_message",
        "importPath": "sentry_sdk",
        "description": "sentry_sdk",
        "isExtraImport": true,
        "detail": "sentry_sdk",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "Patient",
        "importPath": "patient.models",
        "description": "patient.models",
        "isExtraImport": true,
        "detail": "patient.models",
        "documentation": {}
    },
    {
        "label": "Clinic",
        "importPath": "clinic.models",
        "description": "clinic.models",
        "isExtraImport": true,
        "detail": "clinic.models",
        "documentation": {}
    },
    {
        "label": "DentistClinic",
        "importPath": "dentist_clinic.models",
        "description": "dentist_clinic.models",
        "isExtraImport": true,
        "detail": "dentist_clinic.models",
        "documentation": {}
    },
    {
        "label": "DentistProfile",
        "importPath": "dentist_profile.models",
        "description": "dentist_profile.models",
        "isExtraImport": true,
        "detail": "dentist_profile.models",
        "documentation": {}
    },
    {
        "label": "ArchivedPatient",
        "importPath": "archived_patient.models",
        "description": "archived_patient.models",
        "isExtraImport": true,
        "detail": "archived_patient.models",
        "documentation": {}
    },
    {
        "label": "execute_raw_sql",
        "importPath": "utils.raw_sql_utils",
        "description": "utils.raw_sql_utils",
        "isExtraImport": true,
        "detail": "utils.raw_sql_utils",
        "documentation": {}
    },
    {
        "label": "AuthenticationConfig",
        "kind": 6,
        "importPath": "authentication.apps",
        "description": "authentication.apps",
        "peekOfCode": "class AuthenticationConfig(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = 'authentication'",
        "detail": "authentication.apps",
        "documentation": {}
    },
    {
        "label": "AdminBaseJSONWebTokenAuthentication",
        "kind": 6,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "class AdminBaseJSONWebTokenAuthentication(BaseAuthentication):\n    \"\"\"\n    Token based authentication using the JSON Web Token standard.\n    \"\"\"\n    def get_jwt_value(self, request):\n        pass\n    def authenticate(self, request):\n        \"\"\"\n        Returns a two-tuple of `User` and token if a valid signature has been\n        supplied using JWT-based authentication.  Otherwise returns `None`.",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "AdminJSONWebTokenAuthentication",
        "kind": 6,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "class AdminJSONWebTokenAuthentication(AdminBaseJSONWebTokenAuthentication):\n    \"\"\"\n    Clients should authenticate by passing the token key in the \"Authorization\"\n    HTTP header, prepended with the string specified in the setting\n    `JWT_AUTH_HEADER_PREFIX`. For example:\n        Authorization: JWT eyJhbGciOiAiSFMyNTYiLCAidHlwIj\n    \"\"\"\n    www_authenticate_realm = 'api'\n    def get_jwt_value(self, request):\n        auth = get_authorization_header(request).split()",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "custom_admin_authentication",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def custom_admin_authentication(request, email, password):\n  return authenticate(request, email=email, password=password)\nclass AdminBaseJSONWebTokenAuthentication(BaseAuthentication):\n    \"\"\"\n    Token based authentication using the JSON Web Token standard.\n    \"\"\"\n    def get_jwt_value(self, request):\n        pass\n    def authenticate(self, request):\n        \"\"\"",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_get_secret_key",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_get_secret_key(payload=None):\n    \"\"\"\n    For enhanced security you may want to use a secret key based on user.\n    This way you have an option to logout only this user if:\n        - token is compromised\n        - password is changed\n        - etc.\n    \"\"\"\n    if settings.ADMIN_JWT_AUTH['JWT_GET_USER_SECRET_KEY']:\n        # User = get_user_model()  # noqa: N806",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_payload_handler(user):\n    email_field = 'email'\n    email = user.email\n    warnings.warn(\n        'The following fields will be removed in the future: '\n        '`email` and `id`. ',\n        DeprecationWarning\n    )\n    exp = datetime.utcnow() + settings.ADMIN_JWT_AUTH['JWT_EXPIRATION_DELTA']\n    payload = {",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_get_id_from_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_get_id_from_payload_handler(payload):\n    \"\"\"\n    Override this function if id is formatted differently in payload\n    \"\"\"\n    warnings.warn(\n        'The following will be removed in the future. '\n        'Use `JWT_PAYLOAD_GET_USERNAME_HANDLER` instead.',\n        DeprecationWarning\n    )\n    return payload.get('id')",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_get_email_from_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_get_email_from_payload_handler(payload):\n    \"\"\"\n    Override this function if email is formatted differently in payload\n    \"\"\"\n    return payload.get('email')\ndef admin_jwt_encode_handler(payload):\n    key = settings.ADMIN_JWT_AUTH['JWT_PRIVATE_KEY'] or admin_jwt_get_secret_key(payload)\n    return jwt.encode(\n        payload,\n        key,",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_encode_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_encode_handler(payload):\n    key = settings.ADMIN_JWT_AUTH['JWT_PRIVATE_KEY'] or admin_jwt_get_secret_key(payload)\n    return jwt.encode(\n        payload,\n        key,\n        settings.ADMIN_JWT_AUTH['JWT_ALGORITHM']\n    ).decode('utf-8')\ndef admin_jwt_decode_handler(token):\n    options = {\n        'verify_exp': settings.ADMIN_JWT_AUTH['JWT_VERIFY_EXPIRATION'],",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_decode_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_decode_handler(token):\n    options = {\n        'verify_exp': settings.ADMIN_JWT_AUTH['JWT_VERIFY_EXPIRATION'],\n    }\n    # get user from token, BEFORE verification, to get user secret key\n    unverified_payload = jwt.decode(token, None, False)\n    secret_key = admin_jwt_get_secret_key(unverified_payload)\n    # str_token = token.decode('utf-8').strip()\n    str_token = str(token, 'utf-8').strip()\n    res = jwt.decode(",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "admin_jwt_response_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_admin_jwt",
        "description": "authentication.custom_admin_jwt",
        "peekOfCode": "def admin_jwt_response_payload_handler(token, user=None, request=None):\n    \"\"\"\n    Returns the response data for both the login and refresh views.\n    Override to return a custom response such as including the\n    serialized representation of the User.\n    Example:\n    def jwt_response_payload_handler(token, user=None, request=None):\n        return {\n            'token': token,\n            'user': UserSerializer(user, context={'request': request}).data",
        "detail": "authentication.custom_admin_jwt",
        "documentation": {}
    },
    {
        "label": "BaseJSONWebTokenAuthentication",
        "kind": 6,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "class BaseJSONWebTokenAuthentication(BaseAuthentication):\n    \"\"\"\n    Token based authentication using the JSON Web Token standard.\n    \"\"\"\n    def get_jwt_value(self, request):\n        pass\n    def authenticate(self, request):\n        \"\"\"\n        Returns a two-tuple of `User` and token if a valid signature has been\n        supplied using JWT-based authentication.  Otherwise returns `None`.",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "JSONWebTokenAuthentication",
        "kind": 6,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "class JSONWebTokenAuthentication(BaseJSONWebTokenAuthentication):\n    \"\"\"\n    Clients should authenticate by passing the token key in the \"Authorization\"\n    HTTP header, prepended with the string specified in the setting\n    `JWT_AUTH_HEADER_PREFIX`. For example:\n        Authorization: JWT eyJhbGciOiAiSFMyNTYiLCAidHlwIj\n    \"\"\"\n    www_authenticate_realm = 'api'\n    def get_jwt_value(self, request):\n        auth = get_authorization_header(request).split()",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_get_secret_key",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_get_secret_key(payload=None):\n    \"\"\"\n    For enhanced security you may want to use a secret key based on member.\n    This way you have an option to logout only this member if:\n        - token is compromised\n        - password is changed\n        - etc.\n    \"\"\"\n    if settings.JWT_AUTH['JWT_GET_USER_SECRET_KEY']:\n        # Member = get_member_model()  # noqa: N806",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_payload_handler(member):\n    email_field = 'email'\n    email = member.email\n    warnings.warn(\n        'The following fields will be removed in the future: '\n        '`email` and `id`. ',\n        DeprecationWarning\n    )\n    exp = datetime.utcnow() + settings.JWT_AUTH['JWT_EXPIRATION_DELTA']\n    payload = {",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_get_id_from_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_get_id_from_payload_handler(payload):\n    \"\"\"\n    Override this function if id is formatted differently in payload\n    \"\"\"\n    warnings.warn(\n        'The following will be removed in the future. '\n        'Use `JWT_PAYLOAD_GET_USERNAME_HANDLER` instead.',\n        DeprecationWarning\n    )\n    return payload.get('id')",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_get_email_from_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_get_email_from_payload_handler(payload):\n    \"\"\"\n    Override this function if email is formatted differently in payload\n    \"\"\"\n    return payload.get('email')\ndef jwt_encode_handler(payload):\n    key = settings.JWT_AUTH['JWT_PRIVATE_KEY'] or jwt_get_secret_key(payload)\n    return jwt.encode(\n        payload,\n        key,",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_encode_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_encode_handler(payload):\n    key = settings.JWT_AUTH['JWT_PRIVATE_KEY'] or jwt_get_secret_key(payload)\n    return jwt.encode(\n        payload,\n        key,\n        settings.JWT_AUTH['JWT_ALGORITHM']\n    ).decode('utf-8')\ndef jwt_decode_handler(token):\n    options = {\n        'verify_exp': settings.JWT_AUTH['JWT_VERIFY_EXPIRATION'],",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_decode_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_decode_handler(token):\n    options = {\n        'verify_exp': settings.JWT_AUTH['JWT_VERIFY_EXPIRATION'],\n    }\n    # get member from token, BEFORE verification, to get member secret key\n    unverified_payload = jwt.decode(token, None, False)\n    secret_key = jwt_get_secret_key(unverified_payload)\n    # str_token = token.decode('utf-8').strip()\n    str_token = str(token, 'utf-8').strip()\n    res = jwt.decode(",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "jwt_response_payload_handler",
        "kind": 2,
        "importPath": "authentication.custom_jwt",
        "description": "authentication.custom_jwt",
        "peekOfCode": "def jwt_response_payload_handler(token, member=None, request=None):\n    \"\"\"\n    Returns the response data for both the login and refresh views.\n    Override to return a custom response such as including the\n    serialized representation of the Member.\n    Example:\n    def jwt_response_payload_handler(token, member=None, request=None):\n        return {\n            'token': token,\n            'member': MemberSerializer(member, context={'request': request}).data",
        "detail": "authentication.custom_jwt",
        "documentation": {}
    },
    {
        "label": "IsOwnerOrReadOnly",
        "kind": 6,
        "importPath": "authentication.custom_permissions",
        "description": "authentication.custom_permissions",
        "peekOfCode": "class IsOwnerOrReadOnly(permissions.BasePermission):\n  \"\"\"\n  Object-level permission to only allow owners of an object to edit it.\n  Assumes the model instance has an `owner` attribute.\n  \"\"\"\n  def has_object_permission(self, request, view, obj):\n    return obj.owner == request.member\nclass AllowAny(permissions.BasePermission):\n    \"\"\"\n    Allow any access.",
        "detail": "authentication.custom_permissions",
        "documentation": {}
    },
    {
        "label": "AllowAny",
        "kind": 6,
        "importPath": "authentication.custom_permissions",
        "description": "authentication.custom_permissions",
        "peekOfCode": "class AllowAny(permissions.BasePermission):\n    \"\"\"\n    Allow any access.\n    This isn't strictly required, since you could use an empty\n    permission_classes list, but it's useful because it makes the intention\n    more explicit.\n    \"\"\"\n    def has_permission(self, request, view):\n        return True\nclass IsAuthenticated(permissions.BasePermission):",
        "detail": "authentication.custom_permissions",
        "documentation": {}
    },
    {
        "label": "IsAuthenticated",
        "kind": 6,
        "importPath": "authentication.custom_permissions",
        "description": "authentication.custom_permissions",
        "peekOfCode": "class IsAuthenticated(permissions.BasePermission):\n    \"\"\"\n    Allows access only to authenticated members.\n    \"\"\"\n    def has_permission(self, request, view):\n        member = request.user\n        if bool(member and member.is_authenticated):\n            return True\n        return False\nclass IsAdminUser(permissions.BasePermission):",
        "detail": "authentication.custom_permissions",
        "documentation": {}
    },
    {
        "label": "IsAdminUser",
        "kind": 6,
        "importPath": "authentication.custom_permissions",
        "description": "authentication.custom_permissions",
        "peekOfCode": "class IsAdminUser(permissions.BasePermission):\n    \"\"\"\n    Allows access only to admin members.\n    \"\"\"\n    def has_permission(self, request, view):\n        if request.user is None:\n            return False\n        try:\n            exist_is_superuser = request.user._meta.get_field('is_superuser')\n            if exist_is_superuser:",
        "detail": "authentication.custom_permissions",
        "documentation": {}
    },
    {
        "label": "LoginSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class LoginSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n      'password',\n    )\nclass RegisterSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "RegisterSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class RegisterSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n      'type',\n      'first_name',\n      'last_name',\n      'sex',\n      'telnumber',",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "RegisterByEmailSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class RegisterByEmailSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n      'type',\n      'first_name',\n      'last_name',\n      'sex',\n      'telnumber',",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "ChangeEmailSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class ChangeEmailSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n    )\nclass ChangePasswordSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "ChangePasswordSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class ChangePasswordSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n      'new_password'\n    )\nclass ForgetPasswordSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "ForgetPasswordSerializer",
        "kind": 6,
        "importPath": "authentication.serializers",
        "description": "authentication.serializers",
        "peekOfCode": "class ForgetPasswordSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'email',\n    )",
        "detail": "authentication.serializers",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "authentication.urls",
        "description": "authentication.urls",
        "peekOfCode": "urlpatterns = [\n  path('login/', views.CustomLogin.as_view()),\n  # path('login_by_email/', views.CustomLoginByEmail.as_view()),\n  path('logout/', views.Logout.as_view()),\n  path('register/', views.Register.as_view()),\n  # path('register_by_email/', views.RegisterByEmail.as_view()),\n  path('forget_password/', views.ForgetPassword.as_view()),\n  path('change_user_info/changeMail/', views.ChangeUserInfoMail.as_view()),\n  path('change_user_info/changePassword/', views.ChangeUserInfoPassword.as_view()),\n  path('change_user_info/resetPassword/', views.ChangeUserResetPassword.as_view()),",
        "detail": "authentication.urls",
        "documentation": {}
    },
    {
        "label": "CustomLogin",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class CustomLogin(APIView):\n    permission_classes = []\n    def process_admin_user(self, request, admin, serializer):\n      admin_user = custom_admin_authentication(\n        request, \n        email=serializer.data['email'],\n        password=serializer.data['password']\n      )\n      if admin_user is None:\n        return Response(status=status.HTTP_401_UNAUTHORIZED)",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "CustomLoginByEmail",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class CustomLoginByEmail(APIView):\n    permission_classes = []\n    def process_admin_user(self, request, admin, serializer):\n      admin_user = custom_admin_authentication(\n        request, \n        email=serializer.data['email'],\n        password=serializer.data['password']\n      )\n      if admin_user is None:\n        return Response(status=status.HTTP_401_UNAUTHORIZED)",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "Logout",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class Logout(APIView):\n    permission_classes = []\n    def post(self, request, *args, **kwargs):\n        # simply delete the token to force a login\n        user = request.user\n        try:\n            if hasattr(user, 'auth_token'):\n              user.auth_token.delete()\n        except (AttributeError, ObjectDoesNotExist) as ex:\n            logger.error(f'logout error: {str(ex)} on {ex.__traceback__.tb_lineno} line')",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "Register",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class Register(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=RegisterSerializer(many=False),\n        responses={200: MemberSerializer(many=False)}\n    )\n    def post(self, request, format=None):      \n      serializer = RegisterSerializer(data=request.data, many=False)\n      if serializer.is_valid():\n        # if 'udid' in serializer.data:",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "ChangeUserInfo",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class ChangeUserInfo(APIView):\n  permission_classes = []\n  @swagger_auto_schema(\n      request_body=RegisterSerializer(many=False),\n      responses={200: MemberSerializer(many=False)}\n  )\n  def post(self, request, format=None):      \n    serializer = LoginSerializer(\n      data=request.data,\n      context={'request': request}",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "RegisterByEmail",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class RegisterByEmail(APIView):\n    permission_classes = []\n    def update_and_resend_verifiction_token(self, request, member):\n      member_serializer = MemberSerializer(member, request.data)\n      if member_serializer.is_valid():\n        member_serializer.save()\n        member.save()\n        send_email(member)\n        return Response(member_serializer.validated_data, status=status.HTTP_200_OK)\n      else:",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "ForgetPassword",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class ForgetPassword(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=ForgetPasswordSerializer(many=False),\n        responses={200: {}}\n    )\n    def post(self, request, format=None):      \n      serializer = ForgetPasswordSerializer(data=request.data, many=False)\n      if serializer.is_valid():\n        # Check validation",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "ChangeUserInfoMail",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class ChangeUserInfoMail(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=ChangeEmailSerializer(many=False),\n        responses={200: {}}\n    )\n    def post(self, request, format=None):      \n      serializer = ChangeEmailSerializer(data=request.data, many=False)\n      if serializer.is_valid():\n        # Check validation",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "ChangeUserInfoPassword",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class ChangeUserInfoPassword(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=ChangePasswordSerializer(many=False),\n        responses={200: {}}\n    )\n    def post(self, request, format=None):      \n      serializer = ChangePasswordSerializer(data=request.data, many=False)\n      if serializer.is_valid():\n        # Check validation",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "ChangeUserResetPassword",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class ChangeUserResetPassword(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=ChangePasswordSerializer(many=False),\n        responses={200: {}}\n    )\n    def post(self, request, format=None):      \n      serializer = ChangePasswordSerializer(data=request.data, many=False)\n      if serializer.is_valid():\n        # Check validation",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "VerifyResetPasswordToken",
        "kind": 6,
        "importPath": "authentication.views",
        "description": "authentication.views",
        "peekOfCode": "class VerifyResetPasswordToken(APIView):\n    permission_classes = []\n    @swagger_auto_schema(\n        request_body=ChangePasswordSerializer(many=False),\n        responses={200: {}}\n    )\n    def post(self, request, format=None):\n      token = request.data['token']\n      if token:\n        success, member = verify_token(token)",
        "detail": "authentication.views",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "config.asgi",
        "description": "config.asgi",
        "peekOfCode": "application = get_asgi_application()",
        "detail": "config.asgi",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent.parent\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-^05ey65*nhi&0*c0x%$f1!zsve^k&1cld(5#%y#a6_%oq$o*yr'\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nDJANGO_APPS = [",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "SECRET_KEY = 'django-insecure-^05ey65*nhi&0*c0x%$f1!zsve^k&1cld(5#%y#a6_%oq$o*yr'\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nDJANGO_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "DEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nDJANGO_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "ALLOWED_HOSTS",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "ALLOWED_HOSTS = []\n# Application definition\nDJANGO_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "DJANGO_APPS",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "DJANGO_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\nTHIRD_PARTY_APPS=[\n    'rest_framework',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "LOCAL_APPS",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "LOCAL_APPS = [\n    'authentication',\n    'member'\n]\nINSTALLED_APPS = DJANGO_APPS + LOCAL_APPS + THIRD_PARTY_APPS\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ),\n}",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "INSTALLED_APPS",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "INSTALLED_APPS = DJANGO_APPS + LOCAL_APPS + THIRD_PARTY_APPS\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ),\n}\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "REST_FRAMEWORK",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "REST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ),\n}\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "MIDDLEWARE",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "MIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\nROOT_URLCONF = 'config.urls'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "ROOT_URLCONF",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "ROOT_URLCONF = 'config.urls'\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "WSGI_APPLICATION",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "WSGI_APPLICATION = 'config.wsgi.application'\n# Database\n# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\nDATABASES = {\n    # 'default': {\n    #     'ENGINE': 'django.db.backends.sqlite3',\n    #     'NAME': BASE_DIR / 'db.sqlite3',\n    # }\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "DATABASES",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "DATABASES = {\n    # 'default': {\n    #     'ENGINE': 'django.db.backends.sqlite3',\n    #     'NAME': BASE_DIR / 'db.sqlite3',\n    # }\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'NAME': env('DATABASE_NAME', default='itrasyDB'),\n        'USER': env('DATABASE_USER_NAME', default='postgres'),\n        'PASSWORD': env('DATABASE_PASSWORD', default='0523faralahy02'),",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "AUTH_PASSWORD_VALIDATORS",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "AUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "LANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nSTATIC_URL = 'static/'\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "TIME_ZONE",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "TIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nSTATIC_URL = 'static/'\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "USE_I18N",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "USE_I18N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nSTATIC_URL = 'static/'\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "USE_TZ",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "USE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/4.2/howto/static-files/\nSTATIC_URL = 'static/'\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "STATIC_URL",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "STATIC_URL = 'static/'\n# Default primary key field type\n# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_AUTO_FIELD",
        "kind": 5,
        "importPath": "config.settings",
        "description": "config.settings",
        "peekOfCode": "DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "config.settings",
        "documentation": {}
    },
    {
        "label": "trigger_error",
        "kind": 2,
        "importPath": "config.urls",
        "description": "config.urls",
        "peekOfCode": "def trigger_error(request):\n  division_by_zero = 1 / 0\nurlpatterns = [\n    # Admin URL\n    path('super-admin/', admin.site.urls),\n    path('_nested_admin/', include('nested_admin.urls')),\n    # Sentry URL for remote logging\n    path('sentry-debug/', trigger_error),\n    # Auth URL\n    path('email/', include(email_urls)),",
        "detail": "config.urls",
        "documentation": {}
    },
    {
        "label": "schema_view",
        "kind": 5,
        "importPath": "config.urls",
        "description": "config.urls",
        "peekOfCode": "schema_view = get_schema_view(\n  openapi.Info(\n    title=\"itrasy API\",\n    default_version='v1',\n    description=\"REST API for itrasy backend application\",\n    # Moi Julio, j'ai commenté\n    # terms_of_service=env('SWAGGER_BASE_URL', default='https://app.itrasy.com/') + 'termsofservice',\n    # contact=openapi.Contact(email=\"contact@itrasy.com\"),\n    # license=openapi.License(name=\"itrasy\"),\n  ),",
        "detail": "config.urls",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "config.urls",
        "description": "config.urls",
        "peekOfCode": "urlpatterns = [\n    # Admin URL\n    path('super-admin/', admin.site.urls),\n    path('_nested_admin/', include('nested_admin.urls')),\n    # Sentry URL for remote logging\n    path('sentry-debug/', trigger_error),\n    # Auth URL\n    path('email/', include(email_urls)),\n    path('forget_password/', include(forget_password_urls)),\n    path('change_user_info/', include(change_user_info_urls)),",
        "detail": "config.urls",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "config.wsgi",
        "description": "config.wsgi",
        "peekOfCode": "application = get_wsgi_application()",
        "detail": "config.wsgi",
        "documentation": {}
    },
    {
        "label": "verified",
        "kind": 2,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "def verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nSECRET_KEY = 'i6)fwiz^ru7hj^gzk4t=i9la-gi6)s4++4um6+drg^m(g-5c_x'\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django_email_verification',\n]",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "SECRET_KEY = 'i6)fwiz^ru7hj^gzk4t=i9la-gi6)s4++4um6+drg^m(g-5c_x'\nDEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django_email_verification',\n]\nROOT_URLCONF = 'django_email_verification.tests.urls'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "DEBUG = True\nALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django_email_verification',\n]\nROOT_URLCONF = 'django_email_verification.tests.urls'\nTEMPLATES = [",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "ALLOWED_HOSTS",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "ALLOWED_HOSTS = []\n# Application definition\nINSTALLED_APPS = [\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django_email_verification',\n]\nROOT_URLCONF = 'django_email_verification.tests.urls'\nTEMPLATES = [\n    {",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "INSTALLED_APPS",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "INSTALLED_APPS = [\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django_email_verification',\n]\nROOT_URLCONF = 'django_email_verification.tests.urls'\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'tests/templates')]",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "ROOT_URLCONF",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "ROOT_URLCONF = 'django_email_verification.tests.urls'\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'tests/templates')]\n        ,\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'tests/templates')]\n        ,\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "DATABASES",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\n    }\n}\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_L10N = True",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "LANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\ndef verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "TIME_ZONE",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "TIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\ndef verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "USE_I18N",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "USE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\ndef verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "USE_L10N",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "USE_L10N = True\nUSE_TZ = True\ndef verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "USE_TZ",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "USE_TZ = True\ndef verified(user):\n    user.is_active = True\nEMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_VERIFIED_CALLBACK",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_VERIFIED_CALLBACK = verified\nEMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_FROM_ADDRESS",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_FROM_ADDRESS = 'rousseau.platform@gmail.com'\nEMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_MAIL_SUBJECT",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_MAIL_SUBJECT = 'Conferma la tua mail'\nEMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_MAIL_HTML",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_MAIL_HTML = 'mail.html'\nEMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_MAIL_PLAIN",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_MAIL_PLAIN = 'plainmail.txt'\nEMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_TOKEN_LIFE",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_TOKEN_LIFE = 60 * 60\nEMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_PAGE_TEMPLATE",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_PAGE_TEMPLATE = 'confirm.html'\nEMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "EMAIL_PAGE_DOMAIN",
        "kind": 5,
        "importPath": "email_verification.tests.settings",
        "description": "email_verification.tests.settings",
        "peekOfCode": "EMAIL_PAGE_DOMAIN = 'https://test.com/'",
        "detail": "email_verification.tests.settings",
        "documentation": {}
    },
    {
        "label": "get_mail_params",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def get_mail_params(content):\n    expiry = re.findall(r'\\d{1,2}:\\d{1,2}', content)[0]\n    url = re.findall(r'(http|https)://([\\w_-]+(?:(?:\\.[\\w_-]+)+))([\\w.,@?^=%&:/~+#-]*[\\w@?^=%&/~+#-])?',\n                     content)[0][-1]\n    return url, expiry\n@pytest.fixture\ndef test_user():\n    user = get_user_model()(username='test_user', password='test_passwd', email='test@test.com')\n    return user\n@pytest.fixture",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_user",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_user():\n    user = get_user_model()(username='test_user', password='test_passwd', email='test@test.com')\n    return user\n@pytest.fixture\ndef wrong_token_template():\n    match = render_to_string('confirm.html', {'success': False, 'user': None})\n    return match\n@pytest.mark.django_db\ndef test_missing_params(test_user, settings, client):\n    with pytest.raises(NotAllFieldCompiled):",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "wrong_token_template",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def wrong_token_template():\n    match = render_to_string('confirm.html', {'success': False, 'user': None})\n    return match\n@pytest.mark.django_db\ndef test_missing_params(test_user, settings, client):\n    with pytest.raises(NotAllFieldCompiled):\n        settings.EMAIL_FROM_ADDRESS = None\n        send_email(test_user, thread=False)\n    with pytest.raises(InvalidUserModel):\n        send_email(None, thread=False)",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_missing_params",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_missing_params(test_user, settings, client):\n    with pytest.raises(NotAllFieldCompiled):\n        settings.EMAIL_FROM_ADDRESS = None\n        send_email(test_user, thread=False)\n    with pytest.raises(InvalidUserModel):\n        send_email(None, thread=False)\n    with pytest.raises(NotAllFieldCompiled):\n        settings.EMAIL_PAGE_TEMPLATE = None\n        url = '/email/_'\n        client.get(url)",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_email_content",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_email_content(test_user, mailoutbox, settings):\n    test_user.is_active = False\n    send_email(test_user, thread=True)\n    time.sleep(0.5)\n    email = mailoutbox[0]\n    email_content = email.alternatives[0][0]\n    url, expiry = get_mail_params(email_content)\n    assert email.subject == settings.EMAIL_MAIL_SUBJECT, \"The subject changed\"\n    assert email.from_email == settings.EMAIL_FROM_ADDRESS, \"The from_address changed\"\n    assert email.to == [test_user.email], \"The to_address changed\"",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_email_custom_params",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_email_custom_params(test_user, mailoutbox):\n    s_expiry = datetime.now()\n    test_user.is_active = False\n    send_email(test_user, thread=False, custom_salt='test_salt', expiry=s_expiry)\n    email = mailoutbox[0]\n    email_content = email.alternatives[0][0]\n    _, expiry = get_mail_params(email_content)\n    expiry = expiry.split(':')\n    assert s_expiry.time().hour == int(expiry[0]) or s_expiry.time().hour - 12 == int(expiry[0])\n    assert s_expiry.time().minute == int(expiry[1])",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_email_link_correct",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_email_link_correct(test_user, mailoutbox, client):\n    test_user.is_active = False\n    send_email(test_user, thread=False)\n    email = mailoutbox[0]\n    email_content = email.alternatives[0][0]\n    url, _ = get_mail_params(email_content)\n    response = client.get(url)\n    match = render_to_string('confirm.html', {'success': True, 'user': test_user})\n    assert response.content.decode() == match\n@pytest.mark.django_db",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_email_link_wrong",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_email_link_wrong(client, wrong_token_template):\n    url = '/email/dGVzdEB0ZXN0LmNvbE-agax3s-00348f02fabc98235547361a0fe69129b3b750f5'\n    response = client.get(url)\n    assert response.content.decode() == wrong_token_template, \"Invalid token accepted\"\n    url = '/email/_'\n    response = client.get(url)\n    assert response.content.decode() == wrong_token_template, \"Short token accepted\"\n    url = '/email/dGVzdEB0ZXN0LmNvbE++-agax3sert-00=00348f02fabc98235547361a0fe69129b3b750f5'\n    response = client.get(url)\n    assert response.content.decode() == wrong_token_template, \"Long token accepted\"",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_token_different_timestamp",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_token_different_timestamp(test_user, mailoutbox, client, wrong_token_template):\n    test_user.is_active = False\n    send_email(test_user, thread=False)\n    email = mailoutbox[0]\n    email_content = email.alternatives[0][0]\n    url, _ = get_mail_params(email_content)\n    # Increment timestamp\n    token = url.split('-')\n    token[1] = int_to_base36(base36_to_int(token[1]) + 1)\n    url = '-'.join(token)",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_token_expired",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_token_expired(test_user, mailoutbox, settings, client, wrong_token_template):\n    settings.EMAIL_TOKEN_LIFE = 1\n    test_user.is_active = False\n    send_email(test_user, thread=False)\n    email = mailoutbox[0]\n    email_content = email.alternatives[0][0]\n    url, _ = get_mail_params(email_content)\n    time.sleep(2)\n    response = client.get(url)\n    assert response.content.decode() == wrong_token_template",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "test_app_config",
        "kind": 2,
        "importPath": "email_verification.tests.tests",
        "description": "email_verification.tests.tests",
        "peekOfCode": "def test_app_config():\n    from .. import apps\n    assert apps.DjangoEmailConfirmConfig.name == 'django_email_verification', \"Wrong App name\"",
        "detail": "email_verification.tests.tests",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "email_verification.tests.urls",
        "description": "email_verification.tests.urls",
        "peekOfCode": "urlpatterns = [\n    path('email/', include(urls), name='email-endpoint'),\n]",
        "detail": "email_verification.tests.urls",
        "documentation": {}
    },
    {
        "label": "DjangoEmailConfirmConfig",
        "kind": 6,
        "importPath": "email_verification.apps",
        "description": "email_verification.apps",
        "peekOfCode": "class DjangoEmailConfirmConfig(AppConfig):\n    name = 'email_verification'",
        "detail": "email_verification.apps",
        "documentation": {}
    },
    {
        "label": "ChangePasswordForm",
        "kind": 6,
        "importPath": "email_verification.change_password_form",
        "description": "email_verification.change_password_form",
        "peekOfCode": "class ChangePasswordForm(forms.Form):\n    member_id = forms.CharField(widget=forms.HiddenInput(), required=False)\n    member_email = forms.CharField(widget=forms.HiddenInput(), required=False)\n    password = forms.CharField(widget=forms.HiddenInput(), required=False)\n    new_password = forms.CharField(widget=forms.HiddenInput(), required=False)\n    success = forms.BooleanField(widget=forms.HiddenInput(), required=False)\n    def __init__(self,*args,**kwargs):\n        member_id = args[0]['member_id']\n        member_email = args[0]['member_email']\n        new_password = args[0]['new_password']",
        "detail": "email_verification.change_password_form",
        "documentation": {}
    },
    {
        "label": "change_password",
        "kind": 2,
        "importPath": "email_verification.change_password_view",
        "description": "email_verification.change_password_view",
        "peekOfCode": "def change_password(request, token):\n    if request.method == 'POST':\n        form = ChangePasswordForm(request.POST)\n        if form.is_valid():\n            # Save new_password\n            new_password = form.cleaned_data['new_password']\n            member_id = form.cleaned_data['member_id']\n            member = Member.objects.filter(id=member_id).first()\n            member.password = new_password\n            member.save()",
        "detail": "email_verification.change_password_view",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "email_verification.change_user_info_urls",
        "description": "email_verification.change_user_info_urls",
        "peekOfCode": "urlpatterns = [\n    path('password/done/', complete_password_reset),\n    path('password/confirm/', confirm_password_reset),\n    path('password/<str:token>', change_password),\n    path('email/done/', complete_email_reset),\n    path('email/confirm/', confirm_email_reset),\n    path('email/<str:token>', reset_email),\n    path('email/test/', complete_test)\n]",
        "detail": "email_verification.change_user_info_urls",
        "documentation": {}
    },
    {
        "label": "send_email",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_email(member, thread=True, **kwargs):\n    try:\n        member.save()\n        if kwargs.get('custom_salt'):\n            default_token_generator.key_salt = kwargs['custom_salt']\n        expiry_ = kwargs.get('expiry')\n        token, expiry = default_token_generator.make_token(member, expiry_)\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n        subject = _get_validated_field('EMAIL_MAIL_SUBJECT')",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "send_email_thread",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_email_thread(member, token, expiry, sender, domain, subject, mail_plain, mail_html, is_forget_password_request=False):\n    domain += '/' if not domain.endswith('/') else ''\n    from .views import verify\n    link = ''\n    for k, v in get_resolver(None).reverse_dict.items():\n        if k is verify and v[0][0][1][0]:\n            addr = str(v[0][0][0])\n            if is_forget_password_request:\n                link = settings.SITE_URL  + \"/reset-password-form?token=\" + token\n            else:",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "send_email_password_thread",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_email_password_thread(member, token, expiry, sender, domain, subject, mail_plain, mail_html):\n    domain += '/' if not domain.endswith('/') else ''\n    from .views import verify\n    addr = str('password/%(token)s')\n    link = domain + addr[0: addr.index('%')] + token\n    context = {'link': link, 'expiry': expiry, 'member': member}\n    text = render_to_string(mail_plain, context)\n    html = render_to_string(mail_html, context)\n    # msg = EmailMultiAlternatives(subject, text, sender, [member.email])\n    # msg.attach_alternative(html, 'text/html')",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "verify_token",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def verify_token(token):\n    valid, member = default_token_generator.check_token(token)\n    if valid:\n        callback = _get_validated_field('EMAIL_VERIFIED_CALLBACK', default_type=Callable)\n        callback(member)\n        member.login_date = timezone.now()\n        member.save()\n        return valid, member\n    return False, None\ndef send_email_password_reset(member, is_forget_password_request=False,thread=True, **kwargs):",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "send_email_password_reset",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_email_password_reset(member, is_forget_password_request=False,thread=True, **kwargs):\n    try:\n        member.save()\n        if kwargs.get('custom_salt'):\n            default_token_generator.key_salt = kwargs['custom_salt']\n        expiry_ = kwargs.get('expiry')\n        token, expiry = default_token_generator.make_token(member, expiry_)\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN') + 'forget_password/'\n        subject = _get_validated_field('EMAIL_PASSWORD_RESET_MAIL_SUBJECT')",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "send_email_reset",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_email_reset(member, new_email, thread=True, **kwargs):\n    try:\n        member.new_email = new_email\n        member.save()\n        if kwargs.get('custom_salt'):\n            default_token_generator.key_salt = kwargs['custom_salt']\n        expiry_ = kwargs.get('expiry')\n        token, expiry = default_token_generator.make_token(member, expiry_)\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN') + 'change_user_info/'",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "send_password_reset",
        "kind": 2,
        "importPath": "email_verification.confirm",
        "description": "email_verification.confirm",
        "peekOfCode": "def send_password_reset(member, new_password, thread=True, **kwargs):\n    try:\n        member.new_password = new_password\n        member.save()\n        if kwargs.get('custom_salt'):\n            default_token_generator.key_salt = kwargs['custom_salt']\n        expiry_ = kwargs.get('expiry')\n        token, expiry = default_token_generator.make_token(member, expiry_)\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN') + 'change_user_info/'",
        "detail": "email_verification.confirm",
        "documentation": {}
    },
    {
        "label": "InvalidUserModel",
        "kind": 6,
        "importPath": "email_verification.errors",
        "description": "email_verification.errors",
        "peekOfCode": "class InvalidUserModel(Exception):\n    \"\"\"The member model you provided is invalid\"\"\"\n    pass\nclass EmailTemplateNotFound(Exception):\n    \"\"\"No email template found\"\"\"\n    pass\nclass NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass",
        "detail": "email_verification.errors",
        "documentation": {}
    },
    {
        "label": "EmailTemplateNotFound",
        "kind": 6,
        "importPath": "email_verification.errors",
        "description": "email_verification.errors",
        "peekOfCode": "class EmailTemplateNotFound(Exception):\n    \"\"\"No email template found\"\"\"\n    pass\nclass NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass",
        "detail": "email_verification.errors",
        "documentation": {}
    },
    {
        "label": "NotAllFieldCompiled",
        "kind": 6,
        "importPath": "email_verification.errors",
        "description": "email_verification.errors",
        "peekOfCode": "class NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass",
        "detail": "email_verification.errors",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "email_verification.forget_password_urls",
        "description": "email_verification.forget_password_urls",
        "peekOfCode": "urlpatterns = [\n    path('done/', complete_password_reset),\n    path('confirm/', confirm_password_reset),\n    path('email/<str:token>', reset_password),\n]",
        "detail": "email_verification.forget_password_urls",
        "documentation": {}
    },
    {
        "label": "ResetEmailForm",
        "kind": 6,
        "importPath": "email_verification.reset_email_form",
        "description": "email_verification.reset_email_form",
        "peekOfCode": "class ResetEmailForm(forms.Form):\n    member_id = forms.CharField(widget=forms.HiddenInput(), required=False)\n    member_email = forms.CharField(widget=forms.HiddenInput(), required=False)\n    new_email = forms.CharField(widget=forms.HiddenInput(), required=False)\n    success = forms.BooleanField(widget=forms.HiddenInput(), required=False)\n    def __init__(self,*args,**kwargs):\n        member_id = args[0]['member_id']\n        member_email = args[0]['member_email']\n        new_email = args[0]['new_email']\n        success = args[0]['success']",
        "detail": "email_verification.reset_email_form",
        "documentation": {}
    },
    {
        "label": "complete_test",
        "kind": 2,
        "importPath": "email_verification.reset_email_view",
        "description": "email_verification.reset_email_view",
        "peekOfCode": "def complete_test(request):\n    form = ResetEmailForm({\n            'success': False,\n            'member_id': 0,\n            'member_email': None,\n            'new_email': None\n        })\n    return render(request, '../templates/email_reset_complete.html', {'form': form})\ndef reset_email(request, token):\n    if request.method == 'POST':",
        "detail": "email_verification.reset_email_view",
        "documentation": {}
    },
    {
        "label": "reset_email",
        "kind": 2,
        "importPath": "email_verification.reset_email_view",
        "description": "email_verification.reset_email_view",
        "peekOfCode": "def reset_email(request, token):\n    if request.method == 'POST':\n        form = ResetEmailForm(request.POST)\n        if form.is_valid():\n            # Save new_password\n            new_email = form.cleaned_data['new_email']\n            member_id = form.cleaned_data['member_id']\n            member = Member.objects.filter(id=member_id).first()\n            member.email = new_email\n            member.save()",
        "detail": "email_verification.reset_email_view",
        "documentation": {}
    },
    {
        "label": "ResetPasswordForm",
        "kind": 6,
        "importPath": "email_verification.reset_password_form",
        "description": "email_verification.reset_password_form",
        "peekOfCode": "class ResetPasswordForm(forms.Form):\n    new_password = forms.CharField(max_length=32, widget=forms.PasswordInput)\n    confirm_password = forms.CharField(max_length=32, widget=forms.PasswordInput)\n    member_id = forms.CharField(widget=forms.HiddenInput(), required=False)\n    member_email = forms.CharField(widget=forms.HiddenInput(), required=False)\n    success = forms.BooleanField(widget=forms.HiddenInput(), required=False)\n    def __init__(self,*args,**kwargs):\n        member_id = args[0]['member_id']\n        member_email = args[0]['member_email']\n        success = args[0]['success']",
        "detail": "email_verification.reset_password_form",
        "documentation": {}
    },
    {
        "label": "reset_password",
        "kind": 2,
        "importPath": "email_verification.reset_password_view",
        "description": "email_verification.reset_password_view",
        "peekOfCode": "def reset_password(request, token):\n    if request.method == 'POST':\n        form = ResetPasswordForm(request.POST)\n        if form.is_valid():\n            # Save new_password\n            new_password = form.cleaned_data['new_password']\n            member_id = form.cleaned_data['member_id']\n            member = Member.objects.filter(id=member_id).first()\n            member.password = new_password\n            member.save()",
        "detail": "email_verification.reset_password_view",
        "documentation": {}
    },
    {
        "label": "SendMail",
        "kind": 2,
        "importPath": "email_verification.smtp",
        "description": "email_verification.smtp",
        "peekOfCode": "def SendMail(subject, text, html, from_email, to_emails, password):\n  sender_email = from_email\n  receiver_email = to_emails\n  password = password\n  message = MIMEMultipart(\"alternative\")\n  message[\"Subject\"] = subject\n  message[\"From\"] = sender_email\n  message[\"To\"] = receiver_email\n  part1 = MIMEText(text, \"plain\", _charset=\"UTF-8\")\n  part2 = MIMEText(html, \"html\", _charset=\"UTF-8\")",
        "detail": "email_verification.smtp",
        "documentation": {}
    },
    {
        "label": "sender_email",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "sender_email = \"potikuru.master@gmail.com\"\nreceiver_email = \"ninjadev999@gmail.com\"\npassword = 'LpZA6Tv2'\nmessage = MIMEMultipart(\"alternative\")\nmessage[\"Subject\"] = \"multipart test\"\nmessage[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "receiver_email",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "receiver_email = \"ninjadev999@gmail.com\"\npassword = 'LpZA6Tv2'\nmessage = MIMEMultipart(\"alternative\")\nmessage[\"Subject\"] = \"multipart test\"\nmessage[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "password",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "password = 'LpZA6Tv2'\nmessage = MIMEMultipart(\"alternative\")\nmessage[\"Subject\"] = \"multipart test\"\nmessage[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "message",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "message = MIMEMultipart(\"alternative\")\nmessage[\"Subject\"] = \"multipart test\"\nmessage[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:\nwww.realpython.com\"\"\"",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "message[\"Subject\"]",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "message[\"Subject\"] = \"multipart test\"\nmessage[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:\nwww.realpython.com\"\"\"\nhtml = \"\"\"\\",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "message[\"From\"]",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "message[\"From\"] = sender_email\nmessage[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:\nwww.realpython.com\"\"\"\nhtml = \"\"\"\\\n<html>",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "message[\"To\"]",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "message[\"To\"] = receiver_email\n# Create the plain-text and HTML version of your message\ntext = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:\nwww.realpython.com\"\"\"\nhtml = \"\"\"\\\n<html>\n  <body>",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "text = \"\"\"\\\nHi,\nHow are you?\nReal Python has many great tutorials:\nwww.realpython.com\"\"\"\nhtml = \"\"\"\\\n<html>\n  <body>\n    <p>Hi,<br>\n       How are you?<br>",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "html = \"\"\"\\\n<html>\n  <body>\n    <p>Hi,<br>\n       How are you?<br>\n       <a href=\"http://www.realpython.com\">Real Python</a> \n       has many great tutorials.\n    </p>\n  </body>\n</html>",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "part1",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "part1 = MIMEText(text, \"plain\")\npart2 = MIMEText(html, \"html\")\n# Add HTML/plain-text parts to MIMEMultipart message\n# The email client will try to render the last part first\nmessage.attach(part1)\nmessage.attach(part2)\n# Create secure connection with server and send email\ncontext = ssl.create_default_context()\nwith smtplib.SMTP_SSL(\"smtp.gmail.com\", 465, context=context) as server:\n    server.login(sender_email, password)",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "part2",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "part2 = MIMEText(html, \"html\")\n# Add HTML/plain-text parts to MIMEMultipart message\n# The email client will try to render the last part first\nmessage.attach(part1)\nmessage.attach(part2)\n# Create secure connection with server and send email\ncontext = ssl.create_default_context()\nwith smtplib.SMTP_SSL(\"smtp.gmail.com\", 465, context=context) as server:\n    server.login(sender_email, password)\n    server.sendmail(",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "context",
        "kind": 5,
        "importPath": "email_verification.smtp_test",
        "description": "email_verification.smtp_test",
        "peekOfCode": "context = ssl.create_default_context()\nwith smtplib.SMTP_SSL(\"smtp.gmail.com\", 465, context=context) as server:\n    server.login(sender_email, password)\n    server.sendmail(\n        sender_email, receiver_email, message.as_string()\n    )\n    server.close",
        "detail": "email_verification.smtp_test",
        "documentation": {}
    },
    {
        "label": "EmailVerificationTokenGenerator",
        "kind": 6,
        "importPath": "email_verification.token",
        "description": "email_verification.token",
        "peekOfCode": "class EmailVerificationTokenGenerator:\n    \"\"\"\n    Strategy object used to generate and check tokens for the password\n    reset mechanism.\n    \"\"\"\n    key_salt = \"django-email-verification.token\"\n    algorithm = None\n    secret = settings.SECRET_KEY\n    def make_token(self, member, expiry=None):\n        \"\"\"",
        "detail": "email_verification.token",
        "documentation": {}
    },
    {
        "label": "default_token_generator",
        "kind": 5,
        "importPath": "email_verification.token",
        "description": "email_verification.token",
        "peekOfCode": "default_token_generator = EmailVerificationTokenGenerator()",
        "detail": "email_verification.token",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "email_verification.urls",
        "description": "email_verification.urls",
        "peekOfCode": "urlpatterns = [\n    path('<str:token>', verify)\n]",
        "detail": "email_verification.urls",
        "documentation": {}
    },
    {
        "label": "verify",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def verify(request, token):\n    try:\n        template = settings.EMAIL_PAGE_TEMPLATE\n        if not isinstance(template, str):\n            raise AttributeError\n        success, member = verify_token(token)\n        return render(request, template, {'success': success, 'member': member, 'request': request})\n    except AttributeError:\n        raise NotAllFieldCompiled('EMAIL_PAGE_TEMPLATE field not found')\ndef verify_password_reset(request, token):",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "verify_password_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def verify_password_reset(request, token):\n    try:\n        template = settings.PASSWORD_RESET_CONFIRM_TEMPLATE\n        if not isinstance(template, str):\n            raise AttributeError\n        success, member = verify_token(token)\n        return render(request, template, {'success': success, 'member': member, 'request': request})\n    except AttributeError:\n        raise NotAllFieldCompiled('EMAIL_PAGE_TEMPLATE field not found')\ndef verify_mailladdress_reset(request, token):",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "verify_mailladdress_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def verify_mailladdress_reset(request, token):\n    try:\n        template = settings.MAIL_RESET_CONFIRM_TEMPLATE\n        if not isinstance(template, str):\n            raise AttributeError\n        success, member = verify_token(token)\n        return render(request, template, {'success': success, 'member': member, 'request': request})\n    except AttributeError:\n        raise NotAllFieldCompiled('EMAIL_PAGE_TEMPLATE field not found')\ndef confirm_password_reset(request, member):",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "confirm_password_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def confirm_password_reset(request, member):\n    template = settings.PASSWORD_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'success': True, 'member': member, 'request': request})\ndef complete_password_reset(request, member):\n    template = settings.PASSWORD_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'member': member, 'request': request})\ndef confirm_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'success': True, 'member': member, 'request': request})\ndef complete_email_reset(request, member):",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "complete_password_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def complete_password_reset(request, member):\n    template = settings.PASSWORD_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'member': member, 'request': request})\ndef confirm_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'success': True, 'member': member, 'request': request})\ndef complete_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'member': member, 'request': request})",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "confirm_email_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def confirm_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'success': True, 'member': member, 'request': request})\ndef complete_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'member': member, 'request': request})",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "complete_email_reset",
        "kind": 2,
        "importPath": "email_verification.views",
        "description": "email_verification.views",
        "peekOfCode": "def complete_email_reset(request, member):\n    template = settings.MAILADDRESS_RESET_COMPLETE_TEMPLATE\n    return render(request, template, {'member': member, 'request': request})",
        "detail": "email_verification.views",
        "documentation": {}
    },
    {
        "label": "check_in_skip_messages",
        "kind": 2,
        "importPath": "lib.discord.report",
        "description": "lib.discord.report",
        "peekOfCode": "def check_in_skip_messages(message):\n  for sm in SKIP_MESSAGES:\n    if sm in message:\n      return True\n  return False\ndef send_error_report(payload):\n  if check_in_skip_messages(payload['content']): \n    return False\n  return requests.post(settings.DISCORD_CHANNEL_URL, json=payload)\ndef handle_log(log_record, level_id, from_decorator, raw, colored_message, bot_name=\"backend\"):",
        "detail": "lib.discord.report",
        "documentation": {}
    },
    {
        "label": "send_error_report",
        "kind": 2,
        "importPath": "lib.discord.report",
        "description": "lib.discord.report",
        "peekOfCode": "def send_error_report(payload):\n  if check_in_skip_messages(payload['content']): \n    return False\n  return requests.post(settings.DISCORD_CHANNEL_URL, json=payload)\ndef handle_log(log_record, level_id, from_decorator, raw, colored_message, bot_name=\"backend\"):\n  if log_record['level'].name == \"ERROR\":\n    full_msg = \"{asctime} | {levelname} | {process} | {filename}:{function}:{lineno} - {message}\".format(\n      asctime=log_record['time'].strftime('%Y-%m-%d %H:%M:%S'),\n      levelname=log_record['level'].name,\n      process=log_record['process'].name,",
        "detail": "lib.discord.report",
        "documentation": {}
    },
    {
        "label": "handle_log",
        "kind": 2,
        "importPath": "lib.discord.report",
        "description": "lib.discord.report",
        "peekOfCode": "def handle_log(log_record, level_id, from_decorator, raw, colored_message, bot_name=\"backend\"):\n  if log_record['level'].name == \"ERROR\":\n    full_msg = \"{asctime} | {levelname} | {process} | {filename}:{function}:{lineno} - {message}\".format(\n      asctime=log_record['time'].strftime('%Y-%m-%d %H:%M:%S'),\n      levelname=log_record['level'].name,\n      process=log_record['process'].name,\n      filename=log_record['name'],\n      function=log_record['function'],\n      lineno=log_record['line'],\n      message=log_record['message'],",
        "detail": "lib.discord.report",
        "documentation": {}
    },
    {
        "label": "SKIP_MESSAGES",
        "kind": 5,
        "importPath": "lib.discord.report",
        "description": "lib.discord.report",
        "peekOfCode": "SKIP_MESSAGES = [\n  'Signature has expired',\n  'Authentication credentials were not provided',\n  '/api/v1/af_setup_3d_object/find/',\n  'af_setup_3d_object.views.AFSetup3DObjectFind'\n]\ndef check_in_skip_messages(message):\n  for sm in SKIP_MESSAGES:\n    if sm in message:\n      return True",
        "detail": "lib.discord.report",
        "documentation": {}
    },
    {
        "label": "load_loop_functions",
        "kind": 2,
        "importPath": "lib.loguru._asyncio_loop",
        "description": "lib.loguru._asyncio_loop",
        "peekOfCode": "def load_loop_functions():\n    if sys.version_info >= (3, 7):\n        def get_task_loop(task):\n            return task.get_loop()\n        get_running_loop = asyncio.get_running_loop\n    else:\n        def get_task_loop(task):\n            return task._loop\n        def get_running_loop():\n            loop = asyncio.get_event_loop()",
        "detail": "lib.loguru._asyncio_loop",
        "documentation": {}
    },
    {
        "label": "SyntaxHighlighter",
        "kind": 6,
        "importPath": "lib.loguru._better_exceptions",
        "description": "lib.loguru._better_exceptions",
        "peekOfCode": "class SyntaxHighlighter:\n    _default_style = {\n        \"comment\": \"\\x1b[30m\\x1b[1m{}\\x1b[0m\",\n        \"keyword\": \"\\x1b[35m\\x1b[1m{}\\x1b[0m\",\n        \"builtin\": \"\\x1b[1m{}\\x1b[0m\",\n        \"string\": \"\\x1b[36m{}\\x1b[0m\",\n        \"number\": \"\\x1b[34m\\x1b[1m{}\\x1b[0m\",\n        \"operator\": \"\\x1b[35m\\x1b[1m{}\\x1b[0m\",\n        \"punctuation\": \"\\x1b[1m{}\\x1b[0m\",\n        \"constant\": \"\\x1b[36m\\x1b[1m{}\\x1b[0m\",",
        "detail": "lib.loguru._better_exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionFormatter",
        "kind": 6,
        "importPath": "lib.loguru._better_exceptions",
        "description": "lib.loguru._better_exceptions",
        "peekOfCode": "class ExceptionFormatter:\n    _default_theme = {\n        \"introduction\": \"\\x1b[33m\\x1b[1m{}\\x1b[0m\",\n        \"cause\": \"\\x1b[1m{}\\x1b[0m\",\n        \"context\": \"\\x1b[1m{}\\x1b[0m\",\n        \"dirname\": \"\\x1b[32m{}\\x1b[0m\",\n        \"basename\": \"\\x1b[32m\\x1b[1m{}\\x1b[0m\",\n        \"line\": \"\\x1b[33m{}\\x1b[0m\",\n        \"function\": \"\\x1b[35m{}\\x1b[0m\",\n        \"exception_type\": \"\\x1b[31m\\x1b[1m{}\\x1b[0m\",",
        "detail": "lib.loguru._better_exceptions",
        "documentation": {}
    },
    {
        "label": "should_colorize",
        "kind": 2,
        "importPath": "lib.loguru._colorama",
        "description": "lib.loguru._colorama",
        "peekOfCode": "def should_colorize(stream):\n    if stream is None:\n        return False\n    if stream is sys.__stdout__ or stream is sys.__stderr__:\n        if \"PYCHARM_HOSTED\" in os.environ:\n            return True\n        if os.name == \"nt\" and \"TERM\" in os.environ:\n            return True\n    try:\n        return stream.isatty()",
        "detail": "lib.loguru._colorama",
        "documentation": {}
    },
    {
        "label": "should_wrap",
        "kind": 2,
        "importPath": "lib.loguru._colorama",
        "description": "lib.loguru._colorama",
        "peekOfCode": "def should_wrap(stream):\n    if os.name != \"nt\":\n        return False\n    if stream is not sys.__stdout__ and stream is not sys.__stderr__:\n        return False\n    from colorama.win32 import winapi_test\n    return winapi_test()\ndef wrap(stream):\n    from colorama import AnsiToWin32\n    return AnsiToWin32(stream, convert=True, strip=False, autoreset=False).stream",
        "detail": "lib.loguru._colorama",
        "documentation": {}
    },
    {
        "label": "wrap",
        "kind": 2,
        "importPath": "lib.loguru._colorama",
        "description": "lib.loguru._colorama",
        "peekOfCode": "def wrap(stream):\n    from colorama import AnsiToWin32\n    return AnsiToWin32(stream, convert=True, strip=False, autoreset=False).stream",
        "detail": "lib.loguru._colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class Style:\n    RESET_ALL = 0\n    BOLD = 1\n    DIM = 2\n    ITALIC = 3\n    UNDERLINE = 4\n    BLINK = 5\n    REVERSE = 7\n    STRIKE = 8\n    HIDE = 9",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "Fore",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class Fore:\n    BLACK = 30\n    RED = 31\n    GREEN = 32\n    YELLOW = 33\n    BLUE = 34\n    MAGENTA = 35\n    CYAN = 36\n    WHITE = 37\n    RESET = 39",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "Back",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class Back:\n    BLACK = 40\n    RED = 41\n    GREEN = 42\n    YELLOW = 43\n    BLUE = 44\n    MAGENTA = 45\n    CYAN = 46\n    WHITE = 47\n    RESET = 49",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "TokenType",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class TokenType:\n    TEXT = 1\n    ANSI = 2\n    LEVEL = 3\n    CLOSING = 4\nclass AnsiParser:\n    _style = ansi_escape(\n        {\n            \"b\": Style.BOLD,\n            \"d\": Style.DIM,",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "AnsiParser",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class AnsiParser:\n    _style = ansi_escape(\n        {\n            \"b\": Style.BOLD,\n            \"d\": Style.DIM,\n            \"n\": Style.NORMAL,\n            \"h\": Style.HIDE,\n            \"i\": Style.ITALIC,\n            \"l\": Style.BLINK,\n            \"s\": Style.STRIKE,",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "ColoringMessage",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class ColoringMessage(str):\n    __fields__ = (\"_messages\",)\n    def __format__(self, spec):\n        return next(self._messages).__format__(spec)\nclass ColoredMessage:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.stripped = AnsiParser.strip(tokens)\n    def colorize(self, ansi_level):\n        return AnsiParser.colorize(self.tokens, ansi_level)",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "ColoredMessage",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class ColoredMessage:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.stripped = AnsiParser.strip(tokens)\n    def colorize(self, ansi_level):\n        return AnsiParser.colorize(self.tokens, ansi_level)\nclass ColoredFormat:\n    def __init__(self, tokens, messages_color_tokens):\n        self._tokens = tokens\n        self._messages_color_tokens = messages_color_tokens",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "ColoredFormat",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class ColoredFormat:\n    def __init__(self, tokens, messages_color_tokens):\n        self._tokens = tokens\n        self._messages_color_tokens = messages_color_tokens\n    def strip(self):\n        return AnsiParser.strip(self._tokens)\n    def colorize(self, ansi_level):\n        return AnsiParser.colorize(self._tokens, ansi_level)\n    def make_coloring_message(self, message, *, ansi_level, colored_message):\n        messages = [",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "Colorizer",
        "kind": 6,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "class Colorizer:\n    @staticmethod\n    def prepare_format(string):\n        tokens, messages_color_tokens = Colorizer._parse_without_formatting(string)\n        return ColoredFormat(tokens, messages_color_tokens)\n    @staticmethod\n    def prepare_message(string, args=(), kwargs={}):\n        tokens = Colorizer._parse_with_formatting(string, args, kwargs)\n        return ColoredMessage(tokens)\n    @staticmethod",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "ansi_escape",
        "kind": 2,
        "importPath": "lib.loguru._colorizer",
        "description": "lib.loguru._colorizer",
        "peekOfCode": "def ansi_escape(codes):\n    return {name: \"\\033[%dm\" % code for name, code in codes.items()}\nclass TokenType:\n    TEXT = 1\n    ANSI = 2\n    LEVEL = 3\n    CLOSING = 4\nclass AnsiParser:\n    _style = ansi_escape(\n        {",
        "detail": "lib.loguru._colorizer",
        "documentation": {}
    },
    {
        "label": "load_contextvar_class",
        "kind": 2,
        "importPath": "lib.loguru._contextvars",
        "description": "lib.loguru._contextvars",
        "peekOfCode": "def load_contextvar_class():\n    if sys.version_info >= (3, 7):\n        from contextvars import ContextVar\n    elif sys.version_info >= (3, 5, 3):\n        from aiocontextvars import ContextVar\n    else:\n        from contextvars import ContextVar\n    return ContextVar\nContextVar = load_contextvar_class()",
        "detail": "lib.loguru._contextvars",
        "documentation": {}
    },
    {
        "label": "ContextVar",
        "kind": 5,
        "importPath": "lib.loguru._contextvars",
        "description": "lib.loguru._contextvars",
        "peekOfCode": "ContextVar = load_contextvar_class()",
        "detail": "lib.loguru._contextvars",
        "documentation": {}
    },
    {
        "label": "load_ctime_functions",
        "kind": 2,
        "importPath": "lib.loguru._ctime_functions",
        "description": "lib.loguru._ctime_functions",
        "peekOfCode": "def load_ctime_functions():\n    if os.name == \"nt\":\n        import win32_setctime\n        def get_ctime(filepath):\n            return os.stat(filepath).st_ctime\n        def set_ctime(filepath, timestamp):\n            if not win32_setctime.SUPPORTED:\n                return\n            try:\n                win32_setctime.setctime(filepath, timestamp)",
        "detail": "lib.loguru._ctime_functions",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "importPath": "lib.loguru._datetime",
        "description": "lib.loguru._datetime",
        "peekOfCode": "class datetime(datetime_):\n    def __format__(self, spec):\n        if spec.endswith(\"!UTC\"):\n            dt = self.astimezone(timezone.utc)\n            spec = spec[:-4]\n        else:\n            dt = self\n        if not spec:\n            spec = \"%Y-%m-%dT%H:%M:%S.%f%z\"\n        if \"%\" in spec:",
        "detail": "lib.loguru._datetime",
        "documentation": {}
    },
    {
        "label": "aware_now",
        "kind": 2,
        "importPath": "lib.loguru._datetime",
        "description": "lib.loguru._datetime",
        "peekOfCode": "def aware_now():\n    now = datetime.now()\n    timestamp = now.timestamp()\n    local = localtime(timestamp)\n    try:\n        seconds = local.tm_gmtoff\n        zone = local.tm_zone\n    except AttributeError:\n        offset = datetime.fromtimestamp(timestamp) - datetime.utcfromtimestamp(timestamp)\n        seconds = offset.total_seconds()",
        "detail": "lib.loguru._datetime",
        "documentation": {}
    },
    {
        "label": "tokens",
        "kind": 5,
        "importPath": "lib.loguru._datetime",
        "description": "lib.loguru._datetime",
        "peekOfCode": "tokens = r\"H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,6}|YYYY|YY|M{1,4}|D{1,4}|Z{1,2}|zz|A|X|x|E|Q|dddd|ddd|d\"\npattern = re.compile(r\"(?:{0})|\\[(?:{0}|!UTC)\\]\".format(tokens))\nclass datetime(datetime_):\n    def __format__(self, spec):\n        if spec.endswith(\"!UTC\"):\n            dt = self.astimezone(timezone.utc)\n            spec = spec[:-4]\n        else:\n            dt = self\n        if not spec:",
        "detail": "lib.loguru._datetime",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "lib.loguru._datetime",
        "description": "lib.loguru._datetime",
        "peekOfCode": "pattern = re.compile(r\"(?:{0})|\\[(?:{0}|!UTC)\\]\".format(tokens))\nclass datetime(datetime_):\n    def __format__(self, spec):\n        if spec.endswith(\"!UTC\"):\n            dt = self.astimezone(timezone.utc)\n            spec = spec[:-4]\n        else:\n            dt = self\n        if not spec:\n            spec = \"%Y-%m-%dT%H:%M:%S.%f%z\"",
        "detail": "lib.loguru._datetime",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 2,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "def env(key, type_, default=None):\n    if key not in environ:\n        return default\n    val = environ[key]\n    if type_ == str:\n        return val\n    elif type_ == bool:\n        if val.lower() in [\"1\", \"true\", \"yes\", \"y\", \"ok\", \"on\"]:\n            return True\n        if val.lower() in [\"0\", \"false\", \"no\", \"n\", \"nok\", \"off\"]:",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_AUTOINIT",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_AUTOINIT = env(\"LOGURU_AUTOINIT\", bool, True)\nLOGURU_FORMAT = env(\n    \"LOGURU_FORMAT\",\n    str,\n    \"<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | \"\n    \"<level>{level: <8}</level> | \"\n    \"<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>\",\n)\nLOGURU_FILTER = env(\"LOGURU_FILTER\", str, None)\nLOGURU_LEVEL = env(\"LOGURU_LEVEL\", str, \"DEBUG\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_FORMAT",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_FORMAT = env(\n    \"LOGURU_FORMAT\",\n    str,\n    \"<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | \"\n    \"<level>{level: <8}</level> | \"\n    \"<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>\",\n)\nLOGURU_FILTER = env(\"LOGURU_FILTER\", str, None)\nLOGURU_LEVEL = env(\"LOGURU_LEVEL\", str, \"DEBUG\")\nLOGURU_COLORIZE = env(\"LOGURU_COLORIZE\", bool, None)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_FILTER",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_FILTER = env(\"LOGURU_FILTER\", str, None)\nLOGURU_LEVEL = env(\"LOGURU_LEVEL\", str, \"DEBUG\")\nLOGURU_COLORIZE = env(\"LOGURU_COLORIZE\", bool, None)\nLOGURU_SERIALIZE = env(\"LOGURU_SERIALIZE\", bool, False)\nLOGURU_BACKTRACE = env(\"LOGURU_BACKTRACE\", bool, True)\nLOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_LEVEL",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_LEVEL = env(\"LOGURU_LEVEL\", str, \"DEBUG\")\nLOGURU_COLORIZE = env(\"LOGURU_COLORIZE\", bool, None)\nLOGURU_SERIALIZE = env(\"LOGURU_SERIALIZE\", bool, False)\nLOGURU_BACKTRACE = env(\"LOGURU_BACKTRACE\", bool, True)\nLOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_COLORIZE",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_COLORIZE = env(\"LOGURU_COLORIZE\", bool, None)\nLOGURU_SERIALIZE = env(\"LOGURU_SERIALIZE\", bool, False)\nLOGURU_BACKTRACE = env(\"LOGURU_BACKTRACE\", bool, True)\nLOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_SERIALIZE",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_SERIALIZE = env(\"LOGURU_SERIALIZE\", bool, False)\nLOGURU_BACKTRACE = env(\"LOGURU_BACKTRACE\", bool, True)\nLOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_BACKTRACE",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_BACKTRACE = env(\"LOGURU_BACKTRACE\", bool, True)\nLOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_DIAGNOSE",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_DIAGNOSE = env(\"LOGURU_DIAGNOSE\", bool, True)\nLOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_ENQUEUE",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_ENQUEUE = env(\"LOGURU_ENQUEUE\", bool, False)\nLOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_CATCH",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_CATCH = env(\"LOGURU_CATCH\", bool, True)\nLOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_TRACE_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_TRACE_NO = env(\"LOGURU_TRACE_NO\", int, 5)\nLOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_TRACE_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_TRACE_COLOR = env(\"LOGURU_TRACE_COLOR\", str, \"<cyan><bold>\")\nLOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_TRACE_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_TRACE_ICON = env(\"LOGURU_TRACE_ICON\", str, \"✏️\")  # Pencil\nLOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_DEBUG_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_DEBUG_NO = env(\"LOGURU_DEBUG_NO\", int, 10)\nLOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_DEBUG_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_DEBUG_COLOR = env(\"LOGURU_DEBUG_COLOR\", str, \"<blue><bold>\")\nLOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_DEBUG_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_DEBUG_ICON = env(\"LOGURU_DEBUG_ICON\", str, \"🐞\")  # Lady Beetle\nLOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_INFO_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_INFO_NO = env(\"LOGURU_INFO_NO\", int, 20)\nLOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_INFO_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_INFO_COLOR = env(\"LOGURU_INFO_COLOR\", str, \"<bold>\")\nLOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_INFO_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_INFO_ICON = env(\"LOGURU_INFO_ICON\", str, \"ℹ️\")  # Information\nLOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_SUCCESS_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_SUCCESS_NO = env(\"LOGURU_SUCCESS_NO\", int, 25)\nLOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_SUCCESS_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_SUCCESS_COLOR = env(\"LOGURU_SUCCESS_COLOR\", str, \"<green><bold>\")\nLOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_SUCCESS_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_SUCCESS_ICON = env(\"LOGURU_SUCCESS_ICON\", str, \"✔️\")  # Heavy Check Mark\nLOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_WARNING_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_WARNING_NO = env(\"LOGURU_WARNING_NO\", int, 30)\nLOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_WARNING_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_WARNING_COLOR = env(\"LOGURU_WARNING_COLOR\", str, \"<yellow><bold>\")\nLOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_WARNING_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_WARNING_ICON = env(\"LOGURU_WARNING_ICON\", str, \"⚠️\")  # Warning\nLOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_ERROR_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_ERROR_NO = env(\"LOGURU_ERROR_NO\", int, 40)\nLOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_ERROR_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_ERROR_COLOR = env(\"LOGURU_ERROR_COLOR\", str, \"<red><bold>\")\nLOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_ERROR_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_ERROR_ICON = env(\"LOGURU_ERROR_ICON\", str, \"❌\")  # Cross Mark\nLOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_CRITICAL_NO",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_CRITICAL_NO = env(\"LOGURU_CRITICAL_NO\", int, 50)\nLOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_CRITICAL_COLOR",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_CRITICAL_COLOR = env(\"LOGURU_CRITICAL_COLOR\", str, \"<RED><bold>\")\nLOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "LOGURU_CRITICAL_ICON",
        "kind": 5,
        "importPath": "lib.loguru._defaults",
        "description": "lib.loguru._defaults",
        "peekOfCode": "LOGURU_CRITICAL_ICON = env(\"LOGURU_CRITICAL_ICON\", str, \"☠️\")  # Skull and Crossbones",
        "detail": "lib.loguru._defaults",
        "documentation": {}
    },
    {
        "label": "ErrorInterceptor",
        "kind": 6,
        "importPath": "lib.loguru._error_interceptor",
        "description": "lib.loguru._error_interceptor",
        "peekOfCode": "class ErrorInterceptor:\n    def __init__(self, should_catch, handler_id):\n        self._should_catch = should_catch\n        self._handler_id = handler_id\n    def should_catch(self):\n        return self._should_catch\n    def print(self, record=None, *, exception=None):\n        if not sys.stderr:\n            return\n        if exception is None:",
        "detail": "lib.loguru._error_interceptor",
        "documentation": {}
    },
    {
        "label": "FileDateFormatter",
        "kind": 6,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "class FileDateFormatter:\n    def __init__(self, datetime=None):\n        self.datetime = datetime or aware_now()\n    def __format__(self, spec):\n        if not spec:\n            spec = \"%Y-%m-%d_%H-%M-%S_%f\"\n        return self.datetime.__format__(spec)\nclass Compression:\n    @staticmethod\n    def add_compress(path_in, path_out, opener, **kwargs):",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "Compression",
        "kind": 6,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "class Compression:\n    @staticmethod\n    def add_compress(path_in, path_out, opener, **kwargs):\n        with opener(path_out, **kwargs) as f_comp:\n            f_comp.add(path_in, os.path.basename(path_in))\n    @staticmethod\n    def write_compress(path_in, path_out, opener, **kwargs):\n        with opener(path_out, **kwargs) as f_comp:\n            f_comp.write(path_in, os.path.basename(path_in))\n    @staticmethod",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "Retention",
        "kind": 6,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "class Retention:\n    @staticmethod\n    def retention_count(logs, number):\n        def key_log(log):\n            return (-os.stat(log).st_mtime, log)\n        for log in sorted(logs, key=key_log)[number:]:\n            os.remove(log)\n    @staticmethod\n    def retention_age(logs, seconds):\n        t = datetime.now().timestamp()",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "Rotation",
        "kind": 6,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "class Rotation:\n    @staticmethod\n    def forward_day(t):\n        return t + datetime_.timedelta(days=1)\n    @staticmethod\n    def forward_weekday(t, weekday):\n        while True:\n            t += datetime_.timedelta(days=1)\n            if t.weekday() == weekday:\n                return t",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "FileSink",
        "kind": 6,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "class FileSink:\n    def __init__(\n        self,\n        path,\n        *,\n        rotation=None,\n        retention=None,\n        compression=None,\n        delay=False,\n        mode=\"a\",",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "generate_rename_path",
        "kind": 2,
        "importPath": "lib.loguru._file_sink",
        "description": "lib.loguru._file_sink",
        "peekOfCode": "def generate_rename_path(root, ext, creation_time):\n    creation_datetime = datetime.fromtimestamp(creation_time)\n    date = FileDateFormatter(creation_datetime)\n    renamed_path = \"{}.{}{}\".format(root, date, ext)\n    counter = 1\n    while os.path.exists(renamed_path):\n        counter += 1\n        renamed_path = \"{}.{}.{}{}\".format(root, date, counter, ext)\n    return renamed_path\nclass FileDateFormatter:",
        "detail": "lib.loguru._file_sink",
        "documentation": {}
    },
    {
        "label": "filter_none",
        "kind": 2,
        "importPath": "lib.loguru._filters",
        "description": "lib.loguru._filters",
        "peekOfCode": "def filter_none(record):\n    return record[\"name\"] is not None\ndef filter_by_name(record, parent, length):\n    name = record[\"name\"]\n    if name is None:\n        return False\n    return (name + \".\")[:length] == parent\ndef filter_by_level(record, level_per_module):\n    name = record[\"name\"]\n    while True:",
        "detail": "lib.loguru._filters",
        "documentation": {}
    },
    {
        "label": "filter_by_name",
        "kind": 2,
        "importPath": "lib.loguru._filters",
        "description": "lib.loguru._filters",
        "peekOfCode": "def filter_by_name(record, parent, length):\n    name = record[\"name\"]\n    if name is None:\n        return False\n    return (name + \".\")[:length] == parent\ndef filter_by_level(record, level_per_module):\n    name = record[\"name\"]\n    while True:\n        level = level_per_module.get(name, None)\n        if level is False:",
        "detail": "lib.loguru._filters",
        "documentation": {}
    },
    {
        "label": "filter_by_level",
        "kind": 2,
        "importPath": "lib.loguru._filters",
        "description": "lib.loguru._filters",
        "peekOfCode": "def filter_by_level(record, level_per_module):\n    name = record[\"name\"]\n    while True:\n        level = level_per_module.get(name, None)\n        if level is False:\n            return False\n        if level is not None:\n            return record[\"level\"].no >= level\n        if not name:\n            return True",
        "detail": "lib.loguru._filters",
        "documentation": {}
    },
    {
        "label": "get_frame_fallback",
        "kind": 2,
        "importPath": "lib.loguru._get_frame",
        "description": "lib.loguru._get_frame",
        "peekOfCode": "def get_frame_fallback(n):\n    try:\n        raise Exception\n    except Exception:\n        frame = exc_info()[2].tb_frame.f_back\n        for _ in range(n):\n            frame = frame.f_back\n        return frame\ndef load_get_frame_function():\n    if hasattr(sys, \"_getframe\"):",
        "detail": "lib.loguru._get_frame",
        "documentation": {}
    },
    {
        "label": "load_get_frame_function",
        "kind": 2,
        "importPath": "lib.loguru._get_frame",
        "description": "lib.loguru._get_frame",
        "peekOfCode": "def load_get_frame_function():\n    if hasattr(sys, \"_getframe\"):\n        get_frame = sys._getframe\n    else:\n        get_frame = get_frame_fallback\n    return get_frame\nget_frame = load_get_frame_function()",
        "detail": "lib.loguru._get_frame",
        "documentation": {}
    },
    {
        "label": "get_frame",
        "kind": 5,
        "importPath": "lib.loguru._get_frame",
        "description": "lib.loguru._get_frame",
        "peekOfCode": "get_frame = load_get_frame_function()",
        "detail": "lib.loguru._get_frame",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "lib.loguru._handler",
        "description": "lib.loguru._handler",
        "peekOfCode": "class Message(str):\n    __slots__ = (\"record\",)\nclass Handler:\n    def __init__(\n        self,\n        *,\n        sink,\n        name,\n        levelno,\n        formatter,",
        "detail": "lib.loguru._handler",
        "documentation": {}
    },
    {
        "label": "Handler",
        "kind": 6,
        "importPath": "lib.loguru._handler",
        "description": "lib.loguru._handler",
        "peekOfCode": "class Handler:\n    def __init__(\n        self,\n        *,\n        sink,\n        name,\n        levelno,\n        formatter,\n        is_formatter_dynamic,\n        filter_,",
        "detail": "lib.loguru._handler",
        "documentation": {}
    },
    {
        "label": "prepare_colored_format",
        "kind": 2,
        "importPath": "lib.loguru._handler",
        "description": "lib.loguru._handler",
        "peekOfCode": "def prepare_colored_format(format_, ansi_level):\n    colored = Colorizer.prepare_format(format_)\n    return colored, colored.colorize(ansi_level)\ndef prepare_stripped_format(format_):\n    colored = Colorizer.prepare_format(format_)\n    return colored.strip()\ndef memoize(function):\n    return functools.lru_cache(maxsize=64)(function)\nclass Message(str):\n    __slots__ = (\"record\",)",
        "detail": "lib.loguru._handler",
        "documentation": {}
    },
    {
        "label": "prepare_stripped_format",
        "kind": 2,
        "importPath": "lib.loguru._handler",
        "description": "lib.loguru._handler",
        "peekOfCode": "def prepare_stripped_format(format_):\n    colored = Colorizer.prepare_format(format_)\n    return colored.strip()\ndef memoize(function):\n    return functools.lru_cache(maxsize=64)(function)\nclass Message(str):\n    __slots__ = (\"record\",)\nclass Handler:\n    def __init__(\n        self,",
        "detail": "lib.loguru._handler",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "lib.loguru._handler",
        "description": "lib.loguru._handler",
        "peekOfCode": "def memoize(function):\n    return functools.lru_cache(maxsize=64)(function)\nclass Message(str):\n    __slots__ = (\"record\",)\nclass Handler:\n    def __init__(\n        self,\n        *,\n        sink,\n        name,",
        "detail": "lib.loguru._handler",
        "documentation": {}
    },
    {
        "label": "Core",
        "kind": 6,
        "importPath": "lib.loguru._logger",
        "description": "lib.loguru._logger",
        "peekOfCode": "class Core:\n    def __init__(self):\n        levels = [\n            Level(\n                \"TRACE\",\n                _defaults.LOGURU_TRACE_NO,\n                _defaults.LOGURU_TRACE_COLOR,\n                _defaults.LOGURU_TRACE_ICON,\n            ),\n            Level(",
        "detail": "lib.loguru._logger",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "lib.loguru._logger",
        "description": "lib.loguru._logger",
        "peekOfCode": "class Logger:\n    \"\"\"An object to dispatch logging messages to configured handlers.\n    The |Logger| is the core object of ``loguru``, every logging configuration and usage pass\n    through a call to one of its methods. There is only one logger, so there is no need to retrieve\n    one before usage.\n    Once the ``logger`` is imported, it can be used to write messages about events happening in your\n    code. By reading the output logs of your application, you gain a better understanding of the\n    flow of your program and you more easily track and debug unexpected behaviors.\n    Handlers to which the logger sends log messages are added using the |add| method. Note that you\n    can use the |Logger| right after import as it comes pre-configured (logs are emitted to",
        "detail": "lib.loguru._logger",
        "documentation": {}
    },
    {
        "label": "Level",
        "kind": 5,
        "importPath": "lib.loguru._logger",
        "description": "lib.loguru._logger",
        "peekOfCode": "Level = namedtuple(\"Level\", [\"name\", \"no\", \"color\", \"icon\"])\nstart_time = aware_now()\ncontext = ContextVar(\"loguru_context\", default={})\nclass Core:\n    def __init__(self):\n        levels = [\n            Level(\n                \"TRACE\",\n                _defaults.LOGURU_TRACE_NO,\n                _defaults.LOGURU_TRACE_COLOR,",
        "detail": "lib.loguru._logger",
        "documentation": {}
    },
    {
        "label": "start_time",
        "kind": 5,
        "importPath": "lib.loguru._logger",
        "description": "lib.loguru._logger",
        "peekOfCode": "start_time = aware_now()\ncontext = ContextVar(\"loguru_context\", default={})\nclass Core:\n    def __init__(self):\n        levels = [\n            Level(\n                \"TRACE\",\n                _defaults.LOGURU_TRACE_NO,\n                _defaults.LOGURU_TRACE_COLOR,\n                _defaults.LOGURU_TRACE_ICON,",
        "detail": "lib.loguru._logger",
        "documentation": {}
    },
    {
        "label": "context",
        "kind": 5,
        "importPath": "lib.loguru._logger",
        "description": "lib.loguru._logger",
        "peekOfCode": "context = ContextVar(\"loguru_context\", default={})\nclass Core:\n    def __init__(self):\n        levels = [\n            Level(\n                \"TRACE\",\n                _defaults.LOGURU_TRACE_NO,\n                _defaults.LOGURU_TRACE_COLOR,\n                _defaults.LOGURU_TRACE_ICON,\n            ),",
        "detail": "lib.loguru._logger",
        "documentation": {}
    },
    {
        "label": "RecordLevel",
        "kind": 6,
        "importPath": "lib.loguru._recattrs",
        "description": "lib.loguru._recattrs",
        "peekOfCode": "class RecordLevel:\n    __slots__ = (\"name\", \"no\", \"icon\")\n    def __init__(self, name, no, icon):\n        self.name = name\n        self.no = no\n        self.icon = icon\n    def __repr__(self):\n        return \"(name=%r, no=%r, icon=%r)\" % (self.name, self.no, self.icon)\n    def __format__(self, spec):\n        return self.name.__format__(spec)",
        "detail": "lib.loguru._recattrs",
        "documentation": {}
    },
    {
        "label": "RecordFile",
        "kind": 6,
        "importPath": "lib.loguru._recattrs",
        "description": "lib.loguru._recattrs",
        "peekOfCode": "class RecordFile:\n    __slots__ = (\"name\", \"path\")\n    def __init__(self, name, path):\n        self.name = name\n        self.path = path\n    def __repr__(self):\n        return \"(name=%r, path=%r)\" % (self.name, self.path)\n    def __format__(self, spec):\n        return self.name.__format__(spec)\nclass RecordThread:",
        "detail": "lib.loguru._recattrs",
        "documentation": {}
    },
    {
        "label": "RecordThread",
        "kind": 6,
        "importPath": "lib.loguru._recattrs",
        "description": "lib.loguru._recattrs",
        "peekOfCode": "class RecordThread:\n    __slots__ = (\"id\", \"name\")\n    def __init__(self, id_, name):\n        self.id = id_\n        self.name = name\n    def __repr__(self):\n        return \"(id=%r, name=%r)\" % (self.id, self.name)\n    def __format__(self, spec):\n        return self.id.__format__(spec)\nclass RecordProcess:",
        "detail": "lib.loguru._recattrs",
        "documentation": {}
    },
    {
        "label": "RecordProcess",
        "kind": 6,
        "importPath": "lib.loguru._recattrs",
        "description": "lib.loguru._recattrs",
        "peekOfCode": "class RecordProcess:\n    __slots__ = (\"id\", \"name\")\n    def __init__(self, id_, name):\n        self.id = id_\n        self.name = name\n    def __repr__(self):\n        return \"(id=%r, name=%r)\" % (self.id, self.name)\n    def __format__(self, spec):\n        return self.id.__format__(spec)\nclass RecordException(namedtuple(\"RecordException\", (\"type\", \"value\", \"traceback\"))):",
        "detail": "lib.loguru._recattrs",
        "documentation": {}
    },
    {
        "label": "RecordException",
        "kind": 6,
        "importPath": "lib.loguru._recattrs",
        "description": "lib.loguru._recattrs",
        "peekOfCode": "class RecordException(namedtuple(\"RecordException\", (\"type\", \"value\", \"traceback\"))):\n    def __repr__(self):\n        return \"(type=%r, value=%r, traceback=%r)\" % (self.type, self.value, self.traceback)\n    def __reduce__(self):\n        # The traceback is not picklable so we need to remove it. Also, some custom exception\n        # values aren't picklable either. For user convenience, we try first to serialize it and\n        # we remove the value in case or error. As an optimization, we could have re-used the\n        # dumped value during unpickling, but this requires using \"pickle.loads()\" which is\n        # flagged as insecure by some security tools.\n        try:",
        "detail": "lib.loguru._recattrs",
        "documentation": {}
    },
    {
        "label": "StreamSink",
        "kind": 6,
        "importPath": "lib.loguru._simple_sinks",
        "description": "lib.loguru._simple_sinks",
        "peekOfCode": "class StreamSink:\n    def __init__(self, stream):\n        self._stream = stream\n        self._flushable = callable(getattr(stream, \"flush\", None))\n        self._stoppable = callable(getattr(stream, \"stop\", None))\n        self._completable = asyncio.iscoroutinefunction(getattr(stream, \"complete\", None))\n    def write(self, message):\n        self._stream.write(message)\n        if self._flushable:\n            self._stream.flush()",
        "detail": "lib.loguru._simple_sinks",
        "documentation": {}
    },
    {
        "label": "StandardSink",
        "kind": 6,
        "importPath": "lib.loguru._simple_sinks",
        "description": "lib.loguru._simple_sinks",
        "peekOfCode": "class StandardSink:\n    def __init__(self, handler):\n        self._handler = handler\n    def write(self, message):\n        record = message.record\n        message = str(message)\n        exc = record[\"exception\"]\n        record = logging.getLogger().makeRecord(\n            record[\"name\"],\n            record[\"level\"].no,",
        "detail": "lib.loguru._simple_sinks",
        "documentation": {}
    },
    {
        "label": "AsyncSink",
        "kind": 6,
        "importPath": "lib.loguru._simple_sinks",
        "description": "lib.loguru._simple_sinks",
        "peekOfCode": "class AsyncSink:\n    def __init__(self, function, loop, error_interceptor):\n        self._function = function\n        self._loop = loop\n        self._error_interceptor = error_interceptor\n        self._tasks = weakref.WeakSet()\n    def write(self, message):\n        try:\n            loop = self._loop or get_running_loop()\n        except RuntimeError:",
        "detail": "lib.loguru._simple_sinks",
        "documentation": {}
    },
    {
        "label": "CallableSink",
        "kind": 6,
        "importPath": "lib.loguru._simple_sinks",
        "description": "lib.loguru._simple_sinks",
        "peekOfCode": "class CallableSink:\n    def __init__(self, function):\n        self._function = function\n    def write(self, message):\n        self._function(message)\n    def stop(self):\n        pass\n    async def complete(self):\n        pass",
        "detail": "lib.loguru._simple_sinks",
        "documentation": {}
    },
    {
        "label": "Frequencies",
        "kind": 6,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "class Frequencies:\n    @staticmethod\n    def hourly(t):\n        dt = t + datetime.timedelta(hours=1)\n        return dt.replace(minute=0, second=0, microsecond=0)\n    @staticmethod\n    def daily(t):\n        dt = t + datetime.timedelta(days=1)\n        return dt.replace(hour=0, minute=0, second=0, microsecond=0)\n    @staticmethod",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_size",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_size(size):\n    size = size.strip()\n    reg = re.compile(r\"([e\\+\\-\\.\\d]+)\\s*([kmgtpezy])?(i)?(b)\", flags=re.I)\n    match = reg.fullmatch(size)\n    if not match:\n        return None\n    s, u, i, b = match.groups()\n    try:\n        s = float(s)\n    except ValueError as e:",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_duration",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_duration(duration):\n    duration = duration.strip()\n    reg = r\"(?:([e\\+\\-\\.\\d]+)\\s*([a-z]+)[\\s\\,]*)\"\n    units = [\n        (\"y|years?\", 31536000),\n        (\"months?\", 2628000),\n        (\"w|weeks?\", 604800),\n        (\"d|days?\", 86400),\n        (\"h|hours?\", 3600),\n        (\"min(?:ute)?s?\", 60),",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_frequency",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_frequency(frequency):\n    frequencies = {\n        \"hourly\": Frequencies.hourly,\n        \"daily\": Frequencies.daily,\n        \"weekly\": Frequencies.weekly,\n        \"monthly\": Frequencies.monthly,\n        \"yearly\": Frequencies.yearly,\n    }\n    frequency = frequency.strip().lower()\n    return frequencies.get(frequency, None)",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_day",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_day(day):\n    days = {\n        \"monday\": 0,\n        \"tuesday\": 1,\n        \"wednesday\": 2,\n        \"thursday\": 3,\n        \"friday\": 4,\n        \"saturday\": 5,\n        \"sunday\": 6,\n    }",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_time",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_time(time):\n    time = time.strip()\n    reg = re.compile(r\"^[\\d\\.\\:]+\\s*(?:[ap]m)?$\", flags=re.I)\n    if not reg.match(time):\n        return None\n    formats = [\n        \"%H\",\n        \"%H:%M\",\n        \"%H:%M:%S\",\n        \"%H:%M:%S.%f\",",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "parse_daytime",
        "kind": 2,
        "importPath": "lib.loguru._string_parsers",
        "description": "lib.loguru._string_parsers",
        "peekOfCode": "def parse_daytime(daytime):\n    daytime = daytime.strip()\n    reg = re.compile(r\"^(.*?)\\s+at\\s+(.*)$\", flags=re.I)\n    match = reg.match(daytime)\n    if match:\n        day, time = match.groups()\n    else:\n        day = time = daytime\n    try:\n        day = parse_day(day)",
        "detail": "lib.loguru._string_parsers",
        "documentation": {}
    },
    {
        "label": "CustomWindow",
        "kind": 6,
        "importPath": "lib.optimize.interface.custom_window",
        "description": "lib.optimize.interface.custom_window",
        "peekOfCode": "class CustomWindow(tk.Tk):\n    def __init__(self, title, icon_path, parent=None):\n        super().__init__(parent)\n        self.icon_path = icon_path\n        self.title(title)\n        icon_image = ImageTk.PhotoImage(Image.open(icon_path))  # Add this line\n        self.wm_iconphoto(True, icon_image)  # Add this line\n        self.iconbitmap(icon_path)\n        self.overrideredirect(True)\n        self.custom_frame = CustomFrame(self, title, icon_path)",
        "detail": "lib.optimize.interface.custom_window",
        "documentation": {}
    },
    {
        "label": "CustomFrame",
        "kind": 6,
        "importPath": "lib.optimize.interface.custom_window",
        "description": "lib.optimize.interface.custom_window",
        "peekOfCode": "class CustomFrame(tk.Frame):\n    def __init__(self, parent, title, icon_path, *args, **kwargs):\n        super().__init__(parent, *args, **kwargs)\n        self.configure(bg='#4d4d4d')\n        self.columnconfigure(0, weight=1)\n        self.columnconfigure(1, weight=0)\n        self.columnconfigure(2, weight=0)\n        self.rowconfigure(0, weight=0)\n        self.title_label = tk.Label(self, text=title, bg='#4d4d4d', fg='white', font=('Arial', 10, 'bold'))\n        self.title_label.grid(row=0, column=0, padx=5, pady=5, sticky='w')",
        "detail": "lib.optimize.interface.custom_window",
        "documentation": {}
    },
    {
        "label": "get_absolute_path",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def get_absolute_path(local_path):\n    \"\"\"\n    Obtient le chemin absolu pour le chemin local donné.\n    Args:\n        local_path (str): Le chemin local à convertir en chemin absolu.\n    Returns:\n        str: Le chemin absolu correspondant.\n    \"\"\"\n    return os.path.abspath(local_path)\ndef find_window_by_type(type, get_frame=False):",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "find_window_by_type",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def find_window_by_type(type, get_frame=False):\n    \"\"\"\n    Recherche et retourne une fenêtre et son index par son type dans la liste des fenêtres.\n    Args:\n        type (str): Le type de fenêtre à rechercher.\n        get_frame (bool, optional): Si True, retourne le cadre associé à la fenêtre (par défaut: False).\n    Returns:\n        tuple: Un tuple contenant la fenêtre et son index dans la liste des fenêtres, ou (None, 0) si non trouvé.\n    \"\"\"\n    index = 0",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "add_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def add_window(type, window, replace=True, frame=None):\n    \"\"\"\n    Ajoute une fenêtre à la liste des fenêtres. Si replace est True, remplace la fenêtre existante du même type.\n    Args:\n        type (str): Le type de fenêtre à ajouter.\n        window (tk.Toplevel): La fenêtre à ajouter.\n        replace (bool, optional): Si True, remplace la fenêtre existante du même type (par défaut: True).\n        frame (tk.Frame, optional): Le cadre associé à la fenêtre (par défaut: None).\n    Returns:\n        None",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "close_window_and_remove_from_list",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def close_window_and_remove_from_list(window_type):\n    \"\"\"\n    Ferme la fenêtre du type spécifié et la supprime de la liste des fenêtres.\n    Args:\n        window_type (str): Le type de fenêtre à fermer.\n    Returns:\n        None\n    \"\"\"\n    window, ind = find_window_by_type(window_type)\n    if window and ind is not None:",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "check_history_file",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def check_history_file(folder_path):\n    \"\"\"\n    Vérifie si des dossiers sont manquants en comparant le fichier history.json aux dossiers présents.\n    Args:\n        folder_path (str): Le chemin du dossier contenant le fichier history.json.\n    Returns:\n        list: Une liste des dossiers manquants.\n    \"\"\"\"\"\"\n    Vérifie si des dossiers sont manquants en comparant le fichier history.json aux dossiers présents.\n    :param folder_path: str, le chemin du dossier contenant le fichier history.json",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "get_server_files_path",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def get_server_files_path():\n    \"\"\"\n    Récupère le chemin des fichiers du serveur à partir du fichier options.txt.\n    Returns:\n        str: Le chemin absolu des fichiers du serveur.\n    \"\"\"\n    # MODIFICATION TO LIST PATIENTS FOLDERS HERE\n    with open(\"options.txt\", \"r\") as file:\n        for line in file.readlines():\n            if line.startswith(\"SERVER_FILES_PATH=\"):",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "open_folder",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def open_folder(folder_path):\n    \"\"\"\n    Ouvre le dossier spécifié dans l'explorateur de fichiers.\n    Args:\n        folder_path (str): Le chemin du dossier à ouvrir.\n    Returns:\n        None\n    \"\"\"\n    os.startfile(os.path.abspath(folder_path))\ndef update_main_window(window, frame, server_files_path):",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "update_main_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def update_main_window(window, frame, server_files_path):\n    \"\"\"\n    Met à jour la fenêtre principale en reconstruisant les boutons de dossier en fonction des dossiers présents dans le chemin des fichiers du serveur.\n    Args:\n        window (tk.Tk): La fenêtre principale.\n        frame (tk.Frame): Le cadre contenant les boutons de dossier.\n        server_files_path (str): Le chemin d'accès au dossier contenant les fichiers du serveur.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "create_new_patient_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def create_new_patient_window(parent, server_files_path, frame):\n    \"\"\"\n    Crée et affiche une fenêtre \"Nouveau patient\" pour saisir les informations d'un nouveau patient et créer un nouveau dossier patient dans les fichiers du serveur.\n    Args:\n        parent (tk.Widget): La fenêtre parente à laquelle la fenêtre \"Nouveau patient\" sera attachée.\n        server_files_path (str): Le chemin d'accès au dossier contenant les fichiers du serveur.\n        frame (tk.Frame): Le cadre contenant les boutons de dossier dans la fenêtre parente.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "create_new_patient_folder",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def create_new_patient_folder(server_files_path, patient_name, practicien_entry=\"\"):\n    \"\"\"\n    Crée un nouveau dossier patient dans le dossier des fichiers du serveur avec le nom du patient donné.\n    Args:\n        server_files_path (str): Le chemin d'accès au dossier contenant les fichiers du serveur.\n        patient_name (str): Le nom du patient pour le nouveau dossier patient.\n        practicien_entry (str): Le nom du praticien pour le nouveau dossier patient. [DEPRECATED]\n    Returns:\n        Union[bool, str]: True si la création a réussi, sinon un message d'erreur indiquant la raison de l'échec.\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "filter_folders",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def filter_folders(search_text, folder_data):\n    \"\"\"\n    Filtre les dossiers en fonction du texte de recherche.\n    Args:\n        search_text (str): Le texte à rechercher.\n        folder_data (list): La liste des noms de dossier.\n    Returns:\n        list: Une liste des dossiers filtrés.\n    \"\"\"\n    search_text_normalized = unidecode.unidecode(search_text.lower().strip())",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "on_search_text_changed",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def on_search_text_changed(search_text, frame, server_files_path):\n    \"\"\"\n    Appelé lorsque le texte de recherche change.\n    Args:\n        search_text (tk.StringVar): Le texte de recherche.\n        frame (tk.Frame): Le cadre contenant les boutons de dossier.\n        server_files_path (str): Le chemin des fichiers du serveur.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "display_filtered_buttons",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def display_filtered_buttons(search_text, frame, server_files_path):\n    \"\"\"\n    Affiche les boutons de dossier filtrés en fonction du texte de recherche.\n    Args:\n        search_text (str): Le texte de recherche.\n        frame (tk.Frame): Le cadre contenant les boutons de dossier.\n        server_files_path (str): Le chemin des fichiers du serveur.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "create_interface",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def create_interface(folder_list, server_files_path):\n    \"\"\"\n    Crée l'interface principale avec les boutons de dossier.\n    Args:\n        folder_list (list): La liste des noms de dossier.\n        server_files_path (str): Le chemin des fichiers du serveur.\n    Returns:\n        None\n    \"\"\"\n    window = tk.Tk()",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "create_buttons_for_folders",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def create_buttons_for_folders(window, frame, folder_list, server_files_path):\n    \"\"\"\n    Crée et affiche des boutons pour chaque dossier dans la liste des dossiers donnée.\n    Args:\n        window (tk.Tk): La fenêtre principale.\n        frame (tk.Frame): Le cadre contenant les boutons de dossier.\n        folder_list (List[str]): La liste des noms de dossier pour lesquels créer des boutons.\n        server_files_path (str): Le chemin d'accès au dossier contenant les fichiers du serveur.\n    Returns:\n        None",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "check_scroll_position",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def check_scroll_position(canvas):\n    \"\"\"\n    Vérifie la position de défilement du canevas et ajuste la position de défilement si nécessaire.\n    Args:\n        canvas (tk.Canvas): Le canevas dont la position de défilement doit être vérifiée.\n    Returns:\n        None\n    \"\"\"\n    x1, y1, x2, y2 = canvas.bbox(\"all\")\n    if y1 < 0:",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "display_folder_details",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def display_folder_details(parent, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):\n    \"\"\"\n    Affiche les détails du dossier dans une nouvelle fenêtre.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n        labelBgColor (str, optional): La couleur d'arrière-plan des étiquettes. Par défaut \"#808080\".\n        max_width (int, optional): La largeur maximale de la fenêtre. Par défaut 550.\n    Returns:",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "create_detail_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def create_detail_window(parent, folder_path):\n    \"\"\"\n    Crée une nouvelle fenêtre de détails pour le dossier spécifié.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        folder_path (str): Le chemin d'accès au dossier.\n    Returns:\n        tk.Toplevel: La nouvelle fenêtre de détails créée, ou None si une fenêtre du même type existe déjà.\n    \"\"\"\n    type = \"folder_detail_\" + os.path.basename(folder_path)",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "open_reply_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def open_reply_window(parent, detail_window, folder_path, index, history_data, history_file_path, title, bg, type):\n    \"\"\"\n    Ouvre une nouvelle fenêtre de réponse pour permettre à l'utilisateur de rédiger et d'envoyer une réponse.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        detail_window (tk.Toplevel): La fenêtre de détail.\n        folder_path (str): Le chemin d'accès au dossier.\n        index (int): L'index de l'élément d'historique.\n        history_data (list): Les données d'historique.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "save_reply_and_close_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def save_reply_and_close_window(index, history_data, history_file_path, reply_message, type, parent, detail_window, folder_path):\n    \"\"\"\n    Enregistre la réponse, met à jour le fichier d'historique JSON, rafraîchit la fenêtre de détails et ferme la fenêtre de réponse.\n    Args:\n        index (int): L'index de l'élément d'historique.\n        history_data (list): Les données d'historique.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n        reply_message (str): Le message de réponse.\n        type (str): Le type de fenêtre.\n        parent (tk.Tk): La fenêtre parente.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "display_detail_window_content",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def display_detail_window_content(parent, detail_window, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):\n    \"\"\"\n    Affiche le contenu de la fenêtre de détails en lisant le fichier d'historique JSON et en créant les widgets appropriés.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        detail_window (tk.Toplevel): La fenêtre de détail.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n        labelBgColor (str, optional): La couleur d'arrière-plan des étiquettes. Par défaut \"#808080\".\n        max_width (int, optional): La largeur maximale de la fenêtre. Par défaut 550.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "add_new_setup_to_history",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def add_new_setup_to_history(history_file_path):\n    with open(history_file_path, 'r', encoding='utf-8') as file:\n        history_data = json.load(file)\n    # Création d'une liste contenant tous les \"eventName\"\n    event_names = [data[\"eventName\"] for data in history_data]\n    # Trouver le chiffre le plus grand dans les \"eventName\"\n    last_setup_number = find_largest_number(event_names)\n    new_setup_number = last_setup_number + 1\n    new_setup = {\n        \"eventName\": f\"Setup {new_setup_number}\",",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "find_largest_number",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def find_largest_number(strings_list):\n    largest_number = 0\n    for s in strings_list:\n        numbers = [int(num) for num in s.split() if num.isdigit()]\n        largest_number = max(largest_number, *numbers)\n    return largest_number\ndef add_new_setup_and_refresh(detail_window, folder_path, history_file_path, labelBgColor, max_width):\n    add_new_setup_to_history(history_file_path)\n    refresh_detail_window_content(detail_window.master, detail_window, folder_path, history_file_path, labelBgColor, max_width)\ndef refresh_detail_window_content(parent, detail_window, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "add_new_setup_and_refresh",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def add_new_setup_and_refresh(detail_window, folder_path, history_file_path, labelBgColor, max_width):\n    add_new_setup_to_history(history_file_path)\n    refresh_detail_window_content(detail_window.master, detail_window, folder_path, history_file_path, labelBgColor, max_width)\ndef refresh_detail_window_content(parent, detail_window, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):\n    \"\"\"\n    Rafraîchit le contenu de la fenêtre de détails en supprimant le contenu existant et en affichant le contenu mis à jour.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        detail_window (tk.Toplevel): La fenêtre de détail.\n        folder_path (str): Le chemin d'accès au dossier.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "refresh_detail_window_content",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def refresh_detail_window_content(parent, detail_window, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):\n    \"\"\"\n    Rafraîchit le contenu de la fenêtre de détails en supprimant le contenu existant et en affichant le contenu mis à jour.\n    Args:\n        parent (tk.Tk): La fenêtre parente.\n        detail_window (tk.Toplevel): La fenêtre de détail.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n        labelBgColor (str, optional): La couleur d'arrière-plan des étiquettes. Par défaut \"#808080\".\n        max_width (int, optional): La largeur maximale de la fenêtre. Par défaut 550.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "get_global_variable",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def get_global_variable(name):\n    \"\"\"\n    Récupère la valeur d'une variable globale dans le fichier options.txt.\n    Args:\n        name (str): Le nom de la variable globale à rechercher.\n    Returns:\n        str: La valeur de la variable globale, ou None si la variable n'est pas trouvée.\n    \"\"\"\n    with open(\"options.txt\", \"r\") as f:\n        lines = f.readlines()",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "open_obj_opt_window",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def open_obj_opt_window(root, folder_path, history_file_path):\n    \"\"\"\n    Ouvre la fenêtre d'optimisation d'objet et lance le processus d'optimisation.\n    Args:\n        root (tk.Tk): La fenêtre racine de l'application.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "read_process_output",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def read_process_output(process, output_label_var, obj_opt_window):\n    \"\"\"\n    Lit la sortie d'un processus en cours d'exécution et met à jour la fenêtre d'optimisation d'objet avec les deux dernières lignes de la sortie.\n    Args:\n        process (subprocess.Popen): Le processus en cours d'exécution.\n        output_label_var (tk.StringVar): La variable pour stocker la sortie du processus.\n        obj_opt_window (tk.Toplevel): La fenêtre d'optimisation d'objet.\n    Returns:\n        None\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "find_patient_name_from_path",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def find_patient_name_from_path(path):\n    \"\"\"\n    Trouve le nom du patient à partir du chemin d'accès.\n    Args:\n        path (str): Le chemin d'accès.\n    Returns:\n        str: Le nom du patient, ou None si le nom n'est pas trouvé.\n    \"\"\"\n    path = path.replace('\\\\', '/')\n    pattern = r'/([^/]+)/[^/]+$'",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "find_last_part_from_path",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def find_last_part_from_path(path):\n    \"\"\"\n    Trouve la dernière partie du chemin d'accès.\n    Args:\n        path (str): Le chemin d'accès.\n    Returns:\n        str: La dernière partie du chemin d'accès.\n    \"\"\"\n    path = path.replace('\\\\', '/')\n    parts = path.split('/')",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "recreate_directory",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def recreate_directory(path, only_create=True):\n    if os.path.exists(path) and not only_create:\n        shutil.rmtree(path)\n    if not os.path.exists(path): os.mkdir(path)\ndef destroy_path(path):\n    if os.path.exists(path):\n        shutil.rmtree(path)\ndef run_obj_optimization(status_label_var, output_label_var, status_label, obj_opt_window, folder_path, history_file_path):\n    \"\"\"\n    Exécute l'optimisation d'objet en utilisant un script d'optimisation externe et met à jour l'interface utilisateur en fonction des résultats.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "destroy_path",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def destroy_path(path):\n    if os.path.exists(path):\n        shutil.rmtree(path)\ndef run_obj_optimization(status_label_var, output_label_var, status_label, obj_opt_window, folder_path, history_file_path):\n    \"\"\"\n    Exécute l'optimisation d'objet en utilisant un script d'optimisation externe et met à jour l'interface utilisateur en fonction des résultats.\n    Args:\n        status_label_var (tk.StringVar): La variable pour stocker le statut de l'optimisation.\n        output_label_var (tk.StringVar): La variable pour stocker la sortie du processus d'optimisation.\n        status_label (tk.Label): L'étiquette pour afficher le statut de l'optimisation.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "run_obj_optimization",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def run_obj_optimization(status_label_var, output_label_var, status_label, obj_opt_window, folder_path, history_file_path):\n    \"\"\"\n    Exécute l'optimisation d'objet en utilisant un script d'optimisation externe et met à jour l'interface utilisateur en fonction des résultats.\n    Args:\n        status_label_var (tk.StringVar): La variable pour stocker le statut de l'optimisation.\n        output_label_var (tk.StringVar): La variable pour stocker la sortie du processus d'optimisation.\n        status_label (tk.Label): L'étiquette pour afficher le statut de l'optimisation.\n        obj_opt_window (tkToplevel): La fenêtre d'optimisation d'objet.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "browse_file",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def browse_file(window, parent, folder_path, history_file_path):\n    \"\"\"\n    Permet à l'utilisateur de parcourir et de sélectionner un fichier compressé (.zip) pour l'optimisation.\n    Args:\n        window (tk.Toplevel): La fenêtre d'extraction à fermer une fois la sélection effectuée.\n        parent (tk.Toplevel): La fenêtre parent de la fenêtre d'extraction.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n    Returns:\n        None",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "display_uncompression_windows",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def display_uncompression_windows(parent, folder_path, history_file_path, labelBgColor=\"#808080\", max_width=550):\n    \"\"\"\n    Affiche une fenêtre pour permettre à l'utilisateur de parcourir et de sélectionner un fichier compressé (.zip) à décompresser.\n    Args:\n        parent (tk.Toplevel): La fenêtre parent de la fenêtre d'extraction.\n        folder_path (str): Le chemin d'accès au dossier.\n        history_file_path (str): Le chemin d'accès au fichier d'historique JSON.\n        labelBgColor (str, optional): Couleur d'arrière-plan des labels. Par défaut : \"#808080\".\n        max_width (int, optional): Largeur maximale de la fenêtre. Par défaut : 550.\n    Returns:",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "is_process_running",
        "kind": 2,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "def is_process_running(process_name, script_name):\n    \"\"\"\n    Vérifie si un processus avec le nom donné et le script donné est en cours d'exécution.\n    Args:\n        process_name (str): Le nom du processus à vérifier.\n        script_name (str): Le nom du script à vérifier.\n    Returns:\n        bool: True si le processus est en cours d'exécution, False sinon.\n    \"\"\"\n    current_pid = os.getpid()",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "list_of_windows",
        "kind": 5,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "list_of_windows = []\noptimization_is_launched = False\ndef get_absolute_path(local_path):\n    \"\"\"\n    Obtient le chemin absolu pour le chemin local donné.\n    Args:\n        local_path (str): Le chemin local à convertir en chemin absolu.\n    Returns:\n        str: Le chemin absolu correspondant.\n    \"\"\"",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "optimization_is_launched",
        "kind": 5,
        "importPath": "lib.optimize.interface.interface",
        "description": "lib.optimize.interface.interface",
        "peekOfCode": "optimization_is_launched = False\ndef get_absolute_path(local_path):\n    \"\"\"\n    Obtient le chemin absolu pour le chemin local donné.\n    Args:\n        local_path (str): Le chemin local à convertir en chemin absolu.\n    Returns:\n        str: Le chemin absolu correspondant.\n    \"\"\"\n    return os.path.abspath(local_path)",
        "detail": "lib.optimize.interface.interface",
        "documentation": {}
    },
    {
        "label": "lerp_color",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def lerp_color(color1, color2, t):\n    \"\"\"\n    Interpole linéairement entre deux couleurs RGB en fonction de la valeur de t.\n    Args:\n        color1 (tuple): La première couleur RGB sous forme de tuple (r, g, b).\n        color2 (tuple): La seconde couleur RGB sous forme de tuple (r, g, b).\n        t (float): Le paramètre d'interpolation, compris entre 0 et 1.\n    Returns:\n        tuple: La couleur RGB interpolée sous forme de tuple (r, g, b).\n    \"\"\"",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "create_styled_button",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def create_styled_button(parent, text, width, height, button_color=\"ff0000\", command=None, radius = 15, text_color=\"ffffff\"):\n    \"\"\"\n    Crée et retourne un bouton stylisé avec les paramètres donnés.\n    Args:\n        parent (tk.Widget): Le widget parent du bouton.\n        text (str): Le texte à afficher sur le bouton.\n        width (int): La largeur du bouton en pixels.\n        height (int): La hauteur du bouton en pixels.\n        button_color (str): La couleur du bouton au format hexadécimal (ex: \"00ff00\" pour vert).\n        command (callable, optional): La fonction à appeler lorsqu'on clique sur le bouton.",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "create_styled_label",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def create_styled_label(parent, text, width, height, label_color=\"ffffff\", text_color=\"ffffff\"):\n    \"\"\"\n    Crée un label personnalisé avec un arrière-plan arrondi et une couleur de texte spécifiée.\n    Args:\n        parent (Tkinter.Widget): Le widget parent auquel le label sera attaché.\n        text (str): Le texte à afficher sur le label.\n        width (int): La largeur du label en pixels.\n        height (int): La hauteur du label en pixels.\n        label_color (str, optional): La couleur de l'arrière-plan du label au format hexadécimal (sans le préfixe #). Par défaut \"ffffff\".\n        text_color (str, optional): La couleur du texte au format hexadécimal (sans le préfixe #). Par défaut \"ffffff\".",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "create_styled_entry",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def create_styled_entry(parent, width, height, textvariable, entry_color=\"ffffff\", text_color=\"ffffff\"):\n    \"\"\"\n    Crée un Entry personnalisé avec un arrière-plan arrondi et une couleur de texte spécifiée.\n    Args:\n        parent (Tkinter.Widget): Le widget parent auquel le Entry sera attaché.\n        width (int): La largeur de l'Entry en pixels.\n        height (int): La hauteur de l'Entry en pixels.\n        entry_color (str, optional): La couleur de l'arrière-plan du Entry au format hexadécimal (sans le préfixe #). Par défaut \"ffffff\".\n        text_color (str, optional): La couleur du texte au format hexadécimal (sans le préfixe #). Par défaut \"ffffff\".\n    Returns:",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "lerp",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def lerp(a, b, t):\n    \"\"\"\n    Interpole linéairement entre deux valeurs en fonction de la valeur de t.\n    Args:\n        a (float): La première valeur.\n        b (float): La seconde valeur.\n        t (float): Le paramètre d'interpolation, compris entre 0 et 1.\n    Returns:\n        float: La valeur interpolée.\n    \"\"\"",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "darker_color",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def darker_color(color, t=0.1):\n    \"\"\"\n    Assombrit une couleur donnée en fonction de la valeur de t.\n    Args:\n        color (str): La couleur au format hexadécimal (ex: \"#00ff00\" pour vert).\n        t (float, optional): Le paramètre d'assombrissement, compris entre 0 et 1. Par défaut 0.1.\n    Returns:\n        str: La couleur assombrie au format hexadécimal (ex: \"#00ff00\" pour vert).\n    \"\"\"\n    r, g, b = tuple(int(color[i:i+2], 16) for i in (1, 3, 5))",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "create_rounded_rect",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def create_rounded_rect(width, height, radius, color):\n    \"\"\"\n    Crée une image de rectangle arrondi avec les dimensions et la couleur spécifiées.\n    Args:\n        width (int): La largeur du rectangle en pixels.\n        height (int): La hauteur du rectangle en pixels.\n        radius (int): Le rayon des coins arrondis en pixels.\n        color (str): La couleur du rectangle au format hexadécimal (ex: \"#00ff00\" pour vert).\n    Returns:\n        PIL.Image.Image: L'image du rectangle arrondi créée.",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "create_rounded_rect_with_circle",
        "kind": 2,
        "importPath": "lib.optimize.interface.style",
        "description": "lib.optimize.interface.style",
        "peekOfCode": "def create_rounded_rect_with_circle(width, height, radius, color, small_circle=False):\n    \"\"\"\n    Crée une image de rectangle arrondi avec les dimensions et la couleur spécifiées et optionnellement un petit cercle.\n    Args:\n        width (int): La largeur du rectangle en pixels.\n        height (int): La hauteur du rectangle en pixels.\n        radius (int): Le rayon des coins arrondis en pixels.\n        color (str): La couleur du rectangle au format hexadécimal (ex: \"#00ff00\" pour vert).\n        small_circle (bool, optional): Si True, un petit cercle sera ajouté en bas à droite du rectangle. Par défaut False.\n    Returns:",
        "detail": "lib.optimize.interface.style",
        "documentation": {}
    },
    {
        "label": "upload_to_aws",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_to_aws(local_file, bucket, s3_file_name):\n  try:\n    response = s3_client.upload_file(local_file, bucket, s3_file_name, ExtraArgs={'ACL': 'public-read'})\n    s3_file_path = f'{AWS_S3_ENDPOINT_URL}/{AWS_STORAGE_BUCKET_NAME}/{s3_file_name}'\n    return s3_file_path\n  except FileNotFoundError:\n    print(\"The file was not found\")\n  except NoCredentialsError:\n    print(\"Credentials not available\")\n  except ClientError as e:",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "generate_unique_file_name",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def generate_unique_file_name(org_file_name):\n  now = datetime.now()\n  name, extension = os.path.splitext(org_file_name)\n  new_file_name = f'{name}-{now.strftime(\"%Y%m%d%H%M%S\")}{extension}'\n  return new_file_name\ndef upload_aligner_file(af_setup_dir, aligner_info, aligner_path, sub_type, file_name):\n  if aligner_path[0] == '/':\n    aligner_path = aligner_path[1:]\n  if aligner_path[-1] == '/':\n    aligner_path = aligner_path[:-1]",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_aligner_file",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_aligner_file(af_setup_dir, aligner_info, aligner_path, sub_type, file_name):\n  if aligner_path[0] == '/':\n    aligner_path = aligner_path[1:]\n  if aligner_path[-1] == '/':\n    aligner_path = aligner_path[:-1]\n  stage_path = os.path.join(af_setup_dir, aligner_path)\n  local_file = os.path.join(af_setup_dir, aligner_path, file_name)\n  print(f'Uploading file: {local_file}')\n  unique_file_name = generate_unique_file_name(file_name)\n  s3_file_name = f'{aligner_info[\"patient_id\"]}/{aligner_info[\"af_setup_name\"]}/{aligner_info[\"aligner_index\"]}/{sub_type}/{unique_file_name}'",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_stage_files",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_stage_files(af_setup_dir, aligner_info, stages, stage_key, file_name_key):\n  aligner_index = aligner_info['aligner_index']\n  stage = stages[aligner_index]\n  file_name = stage[file_name_key]\n  aligner_path = stage['path']\n  s3_url = upload_aligner_file(af_setup_dir, aligner_info, aligner_path, stage_key, file_name)\n  if s3_url:\n    stages[aligner_index][file_name_key] = s3_url\n  return stages\ndef upload_upper_files(af_setup_dir, aligner_info, stages, upper_key, uppers):",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_upper_files",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_upper_files(af_setup_dir, aligner_info, stages, upper_key, uppers):\n  aligner_index = aligner_info['aligner_index']\n  stage = stages[aligner_index]\n  aligner_path = stage['path']\n  uploaded_uppers = {}\n  upper_index = 0\n  for upper in uppers:\n    file_name = upper\n    s3_url = upload_aligner_file(\n      af_setup_dir=af_setup_dir,",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_optimized_files",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_optimized_files(data_json, base_file_path, patient_id, af_setup_name):\n  updated_data = copy.copy(data_json)\n  UPPER_TYPE = 'upper'\n  LOWER_TYPE = 'lower'\n  ATTACH_TYPE = 'attach'\n  STAGES_TYPE = 'stages'\n  upper = data_json[UPPER_TYPE]\n  lower = data_json[LOWER_TYPE]\n  attach = data_json[ATTACH_TYPE]\n  stages = data_json[STAGES_TYPE]",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_expert_aligner_file",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_expert_aligner_file(base_file_path, aligner_info, sub_type, file_name):\n  local_file = os.path.join(base_file_path, file_name)\n  print(f'Uploading the expert file: {local_file}')\n  unique_file_name = generate_unique_file_name(file_name)\n  if sub_type is None:\n    # maybe this is for Mandible.gld and Maxilla.gld files\n    s3_file_name = f'{aligner_info[\"patient_id\"]}/{aligner_info[\"af_setup_name\"]}/{unique_file_name}'\n  else:\n    s3_file_name = f'{aligner_info[\"patient_id\"]}/{aligner_info[\"af_setup_name\"]}/{EXPERT_SUB_DIR}/{sub_type}/{unique_file_name}'\n  print(\"file : \", s3_file_name)",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_expert_upper_files",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_expert_upper_files(base_file_path, aligner_info, upper_key, uppers):\n  uploaded_uppers = []\n  upper_index = 0\n  for upper in uppers:\n    file_name = upper\n    objects_file_path = os.path.join(base_file_path, EXPERT_SUB_DIR)\n    s3_url = upload_expert_aligner_file(\n      base_file_path=objects_file_path,\n      aligner_info=aligner_info,\n      sub_type=upper_key,",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "upload_expert_files",
        "kind": 2,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "def upload_expert_files(data_json, base_file_path, patient_id, af_setup_name, blender_data_file):\n  updated_data = copy.copy(data_json)\n  UPPER_TYPE = 'upper'\n  LOWER_TYPE = 'lower'\n  ATTACH_TYPE = 'attach'\n  MANDIBLE_GLB = 'mandible'\n  MAXILLA_GLB = 'maxilla'\n  MOUTH_GLB = 'mouth'\n  MANDIBLE_GLB_FILE_NAME = 'Mandible.glb'\n  MAXILLA_GLB_FILE_NAME = 'Maxilla.glb'",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "AWS_REGION",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "AWS_REGION = 'eu-west-3'\nAWS_ACCESS_KEY_ID = settings.AWS_ACCESS_KEY_ID\nAWS_SECRET_ACCESS_KEY = settings.AWS_SECRET_ACCESS_KEY\nAWS_S3_ENDPOINT_URL = os.environ.get(\n    'AWS_S3_ENDPOINT_URL', \n    'https://s3-eu-west-3.amazonaws.com'\n)\nAWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME', 'aligneursfrancais-viewer-staging')\ns3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "AWS_ACCESS_KEY_ID",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "AWS_ACCESS_KEY_ID = settings.AWS_ACCESS_KEY_ID\nAWS_SECRET_ACCESS_KEY = settings.AWS_SECRET_ACCESS_KEY\nAWS_S3_ENDPOINT_URL = os.environ.get(\n    'AWS_S3_ENDPOINT_URL', \n    'https://s3-eu-west-3.amazonaws.com'\n)\nAWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME', 'aligneursfrancais-viewer-staging')\ns3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):\n  try:",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "AWS_SECRET_ACCESS_KEY",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "AWS_SECRET_ACCESS_KEY = settings.AWS_SECRET_ACCESS_KEY\nAWS_S3_ENDPOINT_URL = os.environ.get(\n    'AWS_S3_ENDPOINT_URL', \n    'https://s3-eu-west-3.amazonaws.com'\n)\nAWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME', 'aligneursfrancais-viewer-staging')\ns3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):\n  try:\n    response = s3_client.upload_file(local_file, bucket, s3_file_name, ExtraArgs={'ACL': 'public-read'})",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "AWS_S3_ENDPOINT_URL",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "AWS_S3_ENDPOINT_URL = os.environ.get(\n    'AWS_S3_ENDPOINT_URL', \n    'https://s3-eu-west-3.amazonaws.com'\n)\nAWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME', 'aligneursfrancais-viewer-staging')\ns3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):\n  try:\n    response = s3_client.upload_file(local_file, bucket, s3_file_name, ExtraArgs={'ACL': 'public-read'})\n    s3_file_path = f'{AWS_S3_ENDPOINT_URL}/{AWS_STORAGE_BUCKET_NAME}/{s3_file_name}'",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "AWS_STORAGE_BUCKET_NAME",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "AWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME', 'aligneursfrancais-viewer-staging')\ns3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):\n  try:\n    response = s3_client.upload_file(local_file, bucket, s3_file_name, ExtraArgs={'ACL': 'public-read'})\n    s3_file_path = f'{AWS_S3_ENDPOINT_URL}/{AWS_STORAGE_BUCKET_NAME}/{s3_file_name}'\n    return s3_file_path\n  except FileNotFoundError:\n    print(\"The file was not found\")\n  except NoCredentialsError:",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "s3_client",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "s3_client = boto3.client('s3', aws_access_key_id=AWS_ACCESS_KEY_ID, aws_secret_access_key=AWS_SECRET_ACCESS_KEY)\ndef upload_to_aws(local_file, bucket, s3_file_name):\n  try:\n    response = s3_client.upload_file(local_file, bucket, s3_file_name, ExtraArgs={'ACL': 'public-read'})\n    s3_file_path = f'{AWS_S3_ENDPOINT_URL}/{AWS_STORAGE_BUCKET_NAME}/{s3_file_name}'\n    return s3_file_path\n  except FileNotFoundError:\n    print(\"The file was not found\")\n  except NoCredentialsError:\n    print(\"Credentials not available\")",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "EXPERT_SUB_DIR",
        "kind": 5,
        "importPath": "lib.optimize.upload.aws",
        "description": "lib.optimize.upload.aws",
        "peekOfCode": "EXPERT_SUB_DIR = 'objects'\ndef upload_expert_aligner_file(base_file_path, aligner_info, sub_type, file_name):\n  local_file = os.path.join(base_file_path, file_name)\n  print(f'Uploading the expert file: {local_file}')\n  unique_file_name = generate_unique_file_name(file_name)\n  if sub_type is None:\n    # maybe this is for Mandible.gld and Maxilla.gld files\n    s3_file_name = f'{aligner_info[\"patient_id\"]}/{aligner_info[\"af_setup_name\"]}/{unique_file_name}'\n  else:\n    s3_file_name = f'{aligner_info[\"patient_id\"]}/{aligner_info[\"af_setup_name\"]}/{EXPERT_SUB_DIR}/{sub_type}/{unique_file_name}'",
        "detail": "lib.optimize.upload.aws",
        "documentation": {}
    },
    {
        "label": "test_aws_upload",
        "kind": 2,
        "importPath": "lib.optimize.upload.test",
        "description": "lib.optimize.upload.test",
        "peekOfCode": "def test_aws_upload():\n    jsonData = json.loads(strDataJson)\n    jsonData = upload_optimized_files(data_json=jsonData, base_file_path=optimized_files_dir, patient_id='patient1', af_setup_name='Setup_1')\n    # print('==== jsonData: \\n', json.dumps(jsonData))\n    with open (os.path.join(\"up.json\"),'w') as f:\n        json.dump(jsonData,f)\nif __name__ == \"__main__\": \n    test_aws_upload()",
        "detail": "lib.optimize.upload.test",
        "documentation": {}
    },
    {
        "label": "optimized_files_dir",
        "kind": 5,
        "importPath": "lib.optimize.upload.test",
        "description": "lib.optimize.upload.test",
        "peekOfCode": "optimized_files_dir = 'C:\\\\Users\\\\ninja\\\\git\\\\viewer\\\\Aligneur_server_V2\\\\files\\patient1\\\\Setup_1\\\\'\nstrDataJson = \"\"\"\n{\n    \"upper\": [\n        \"Tooth17.obj\",\n        \"Tooth16.obj\",\n        \"Tooth15.obj\",\n        \"Tooth14.obj\",\n        \"Tooth13.obj\",\n        \"Tooth12.obj\",",
        "detail": "lib.optimize.upload.test",
        "documentation": {}
    },
    {
        "label": "strDataJson",
        "kind": 5,
        "importPath": "lib.optimize.upload.test",
        "description": "lib.optimize.upload.test",
        "peekOfCode": "strDataJson = \"\"\"\n{\n    \"upper\": [\n        \"Tooth17.obj\",\n        \"Tooth16.obj\",\n        \"Tooth15.obj\",\n        \"Tooth14.obj\",\n        \"Tooth13.obj\",\n        \"Tooth12.obj\",\n        \"Tooth11.obj\",",
        "detail": "lib.optimize.upload.test",
        "documentation": {}
    },
    {
        "label": "calculate_mesiodistal_width",
        "kind": 2,
        "importPath": "lib.optimize.bolton_analysis",
        "description": "lib.optimize.bolton_analysis",
        "peekOfCode": "def calculate_mesiodistal_width(distal_data, mesial_data):\n    try:\n        distal_x = float(distal_data['X-Pos'])\n        distal_y = float(distal_data['Y-Pos'])\n        distal_z = float(distal_data['Z-Pos'])\n        mesial_x = float(mesial_data['X-Pos'])\n        mesial_y = float(mesial_data['Y-Pos'])\n        mesial_z = float(mesial_data['Z-Pos'])\n    except ValueError:\n        return np.nan",
        "detail": "lib.optimize.bolton_analysis",
        "documentation": {}
    },
    {
        "label": "fill_missing_with_linear_regression",
        "kind": 2,
        "importPath": "lib.optimize.bolton_analysis",
        "description": "lib.optimize.bolton_analysis",
        "peekOfCode": "def fill_missing_with_linear_regression(region_data):\n    # Filter out missing values and prepare data for linear regression\n    x = np.array([tooth_number for tooth_number, tooth_value in region_data.items() if not np.isnan(tooth_value)])\n    y = np.array([tooth_value for tooth_number, tooth_value in region_data.items() if not np.isnan(tooth_value)])\n    # Fit a linear model to the data\n    coeffs = np.polyfit(x, y, 1)\n    linear_regression = np.poly1d(coeffs)\n    # Prepare the result dictionary\n    result = {}\n    for tooth_number, tooth_value in region_data.items():",
        "detail": "lib.optimize.bolton_analysis",
        "documentation": {}
    },
    {
        "label": "get_bolton_analysis",
        "kind": 2,
        "importPath": "lib.optimize.bolton_analysis",
        "description": "lib.optimize.bolton_analysis",
        "peekOfCode": "def get_bolton_analysis(file_path):\n    df = pd.read_excel(file_path, usecols=['Landmarks', 'X-Pos', 'Y-Pos', 'Z-Pos'], engine=\"xlrd\")\n    data = df.set_index('Landmarks').T.to_dict('list')\n    mesiodistal_widths = {}\n    for landmark, positions in data.items():\n        tooth_number = int(landmark[:2]) \n        if tooth_number not in mesiodistal_widths.keys():\n            mesiodistal_widths[tooth_number] = {}\n        if not np.isnan(positions[1]):\n            mesiodistal_widths[tooth_number][landmark[2:]] = dict(zip(['X-Pos', 'Y-Pos', 'Z-Pos'], positions[:3])) ",
        "detail": "lib.optimize.bolton_analysis",
        "documentation": {}
    },
    {
        "label": "calculate_arcade_length",
        "kind": 2,
        "importPath": "lib.optimize.bolton_analysis",
        "description": "lib.optimize.bolton_analysis",
        "peekOfCode": "def calculate_arcade_length(teeth_data1, teeth_data2):\n    predicted = int(any([v['predicted'] for v in teeth_data1.values()] + [v['predicted'] for v in teeth_data2.values()]))\n    length = np.nansum([v['value'] for v in teeth_data1.values()] + [v['value'] for v in teeth_data2.values()])\n    return {'length': round(length, 2), 'predicted': predicted}\n# def main():\n#     file_path = \"Landmarks_Bolton2.xls\"\n#     bolton_analysis = get_bolton_analysis(file_path)\n# if __name__ == \"__main__\":\n#     main()",
        "detail": "lib.optimize.bolton_analysis",
        "documentation": {}
    },
    {
        "label": "get_absolute_path",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def get_absolute_path(path):\n    return os.path.abspath(os.path.expanduser(path))\ndef calculate_total_volume(mesh_list):\n    total_volume = 0\n    for mesh in mesh_list:\n        if mesh.type == 'MESH':\n            bpy.context.view_layer.objects.active = mesh\n            mesh.select_set(True)\n            bpy.ops.object.mode_set(mode='EDIT')\n            bpy.ops.mesh.select_all(action='SELECT')",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "calculate_total_volume",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def calculate_total_volume(mesh_list):\n    total_volume = 0\n    for mesh in mesh_list:\n        if mesh.type == 'MESH':\n            bpy.context.view_layer.objects.active = mesh\n            mesh.select_set(True)\n            bpy.ops.object.mode_set(mode='EDIT')\n            bpy.ops.mesh.select_all(action='SELECT')\n            bpy.ops.object.mode_set(mode='OBJECT')\n            total_volume += mesh.dimensions.x * mesh.dimensions.y * mesh.dimensions.z",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_all_modifiers",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def apply_all_modifiers(obj):\n    for modifier in obj.modifiers:\n        # if modifier.type == 'BOOLEAN':\n            bpy.context.view_layer.objects.active = obj\n            bpy.ops.object.modifier_apply(modifier=modifier.name)\ndef create_gum_material(obj_name):\n    # Create a new material\n    material = bpy.data.materials.new(name=\"Gum_Material\")\n    # Enable 'Use Nodes'\n    material.use_nodes = True",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_gum_material",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_gum_material(obj_name):\n    # Create a new material\n    material = bpy.data.materials.new(name=\"Gum_Material\")\n    # Enable 'Use Nodes'\n    material.use_nodes = True\n    bsdf = material.node_tree.nodes[\"Principled BSDF\"]\n    # Create new nodes\n    separate_xyz = material.node_tree.nodes.new('ShaderNodeSeparateXYZ')\n    color_ramp = material.node_tree.nodes.new('ShaderNodeValToRGB')\n    # Make connections",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_gum_material",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def apply_gum_material(obj):\n    # Create gum material\n    gum_material = create_gum_material(obj.name)\n    # Apply the material to the object\n    if len(obj.data.materials) > 0:\n        # If the object already has a material, replace it\n        obj.data.materials[0] = gum_material\n    else:\n        # If the object has no materials, append it\n        obj.data.materials.append(gum_material)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_bone_scale",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def apply_bone_scale(armature_obj, bones_ind=[]):\n    # Ensure we're in pose mode\n    bpy.ops.object.mode_set(mode='POSE')\n    # Select the bone\n    for bone in armature_obj.pose.bones:\n        # bone = armature_obj.pose.bones[i]\n        bone.bone.select = True\n    # Apply the scale\n    bpy.ops.pose.armature_apply(selected=True)\n    # Deselect the bone",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "deform_from_points",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def deform_from_points(obj, points, offset_curve={0: 0.1, 1: 0.0}, iterations=25, export_path=None, falloff='SPHERE', proportional_adaptation=False, orient_type='GLOBAL', deformation_vector=(0, -1, 0), use_scale=False):\n    # If no specific export path was provided, use the script's directory\n    if export_path is None:\n        export_path = get_absolute_path(\"./\")\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Set the active object to the mesh object\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    # Apply all modifiers before starting the deformation",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "get_closest_point_on_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def get_closest_point_on_mesh(point, obj):\n    # Convert object to bmesh\n    bm = bmesh.new()\n    bm.from_mesh(obj.data)\n    bm.transform(obj.matrix_world)\n    bm.faces.ensure_lookup_table()  # Ensure the internal table is up-to-date before using\n    faces = bm.faces\n    # Create KDTree\n    size = len(faces)\n    kd = mathutils.kdtree.KDTree(size)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "is_inside",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def is_inside(p, obj, direction=1):\n    mat = obj.matrix_world.inverted()\n    # Transformation of the point p to the local coordinates of obj\n    p_local = mat @ p\n    # Creation of a direction vector along the z-axis\n    direction = mathutils.Vector((0, 0, direction))\n    # Cast the ray from the point along the z-axis\n    result, location, normal, index = obj.ray_cast(p_local, direction)\n    return result\ndef group_points(points_to_deform, radius=0.5):",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "group_points",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def group_points(points_to_deform, radius=0.5):\n    # Compute the local density for each point\n    densities = [(point, sum((other - point).length <= radius for other in points_to_deform)) for point in points_to_deform]\n    # Sort the points by their density in descending order\n    sorted_points = [point for point, density in sorted(densities, key=lambda x: x[1], reverse=True)]\n    groups = []\n    while sorted_points:\n        point = sorted_points.pop(0)\n        group = [point]\n        for other in sorted_points[:]:",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "check_and_extrude",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def check_and_extrude(mesh_obj, target_mesh, upper_percentage=0.4, from_upper=False, use_average_point=True, debug_mesh=False):\n    # We get the world coordinates of the bounding box\n    bbox = [mesh_obj.matrix_world @ mathutils.Vector(corner) for corner in mesh_obj.bound_box]\n    # We get the max and min z to determine the upper half\n    min_z = min(corner.z for corner in bbox)\n    max_z = max(corner.z for corner in bbox)\n    direction = -1 if from_upper else 1\n    # Calculate the z-threshold\n    threshold_z = min_z + (max_z - min_z) * (1 - upper_percentage) if not from_upper else min_z + (max_z - min_z) * upper_percentage\n    # Convert the vertices to world coordinates",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "check_and_deform",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def check_and_deform(mesh_obj, target_mesh, upper_percentage=0.4, from_bottom=False, debug_mesh=False):\n    # We get the world coordinates of the bounding box\n    bbox = [mesh_obj.matrix_world @ mathutils.Vector(corner) for corner in mesh_obj.bound_box]\n    # We get the max and min z to determine the upper half\n    min_z = min(corner.z for corner in bbox)\n    max_z = max(corner.z for corner in bbox)\n    direction = -1 if from_bottom else 1\n    # Calculate the z-threshold\n    threshold_z = min_z + (max_z - min_z) * (1 - upper_percentage) if not from_bottom else min_z + (max_z - min_z) * upper_percentage\n    # Convert the vertices to world coordinates",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "deform_lengthen",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def deform_lengthen(obj, height_interval=0.15, translation_offset=2.5, falloff='LINEAR'):\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Set the active object to the mesh object\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    # Apply all modifiers before starting the deformation\n    apply_all_modifiers(obj)\n    # Deselect all vertices\n    bpy.ops.object.mode_set(mode='EDIT')",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "find_and_deform_back",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def find_and_deform_back(obj, offset_curve={0: 0.0, 0.7: 0.3, 0.9: 1.2, 1: 0.0}, iterations=40, falloff='SPHERE', orient_type='GLOBAL', deformation_vector=(0, 1, 0.1), z_interval=0.05, use_scale=False):\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Set the active object to the mesh object\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    # Apply all modifiers before starting the deformation\n    apply_all_modifiers(obj)\n    # Calculate the Z coordinate of the bounding box center\n    bounding_box_center_z = sum((obj.matrix_world @ Vector(b)).z for b in obj.bound_box) / len(obj.bound_box)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_proportional_deformation_by_curve",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_proportional_deformation_by_curve(obj, curve_object, limit_points=[], offset_curve={0: 0.15, 0.5: 0.10, 1: 0.0}, iterations=25, between=True, export_path=None, falloff='SPHERE', direction=[0,0,1], proportional_adaptation=True, orient_type='GLOBAL', surfaces=None, heights=None, only_points= None):\n    def resize_list(lst, target_len):\n        diff = target_len - len(lst)\n        if diff < 0:\n            return lst[:target_len]\n        elif diff > 0:\n            return [lst[0]] * int(diff / 2) + lst + [lst[-1]] * (diff - int(diff / 2))\n        else:\n            return lst\n    if export_path is None:",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_proportional_deformation",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_proportional_deformation(obj, armature_object, offset_curve={0: 0.15, 0.5: 0.10, 1: 0.0}, iterations=25, between=True, export_path=None, falloff='SPHERE', direction=1, proportional_adaptation=True, orient_type='GLOBAL'):\n    # If no specific export path was provided, use the script's directory\n    if export_path is None:\n        export_path = get_absolute_path(\"./\")\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Set the active object to the mesh object\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    # Apply all modifiers before starting the deformation",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "move_spline_point",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def move_spline_point(spline, point_index, translation_vector):\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Deselect all\n    bpy.ops.object.select_all(action='DESELECT')\n    # Set the active object to the spline\n    bpy.context.view_layer.objects.active = spline\n    spline.select_set(True)\n    # Switch to edit mode to adjust the points\n    bpy.ops.object.mode_set(mode='EDIT')",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "export_to_glb",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def export_to_glb(obj_list, name=\"test\", filepath='./'):\n    export_path = get_absolute_path(filepath)\n    bpy.ops.object.mode_set(mode='OBJECT')\n    bpy.ops.object.select_all(action='DESELECT')\n    # Select objects in the list\n    for obj in obj_list:\n        obj.select_set(True)\n    # Export selected objects to glb\n    bpy.ops.export_scene.gltf(filepath=os.path.join(export_path, name + '.glb'), use_selection=True)\ndef local_dimensions(obj):",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "local_dimensions",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def local_dimensions(obj):\n    local_coords = [obj.matrix_world.inverted() @ Vector(corner) for corner in obj.bound_box]\n    rotated_extents = [max(coord[i] for coord in local_coords) - min(coord[i] for coord in local_coords) for i in range(3)]\n    return rotated_extents\ndef sort_and_calculate_dimensions(teeth, position):\n    # Sorting function based on position\n    def sort_upper(teeth):\n        group1 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 1], key=lambda t: int(str(t.name[5:7])[1]), reverse=True)\n        group2 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 2], key=lambda t: int(str(t.name[5:7])[1]))\n        return group1 + group2",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "sort_and_calculate_dimensions",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def sort_and_calculate_dimensions(teeth, position):\n    # Sorting function based on position\n    def sort_upper(teeth):\n        group1 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 1], key=lambda t: int(str(t.name[5:7])[1]), reverse=True)\n        group2 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 2], key=lambda t: int(str(t.name[5:7])[1]))\n        return group1 + group2\n    def sort_lower(teeth):\n        group1 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 4], key=lambda t: int(str(t.name[5:7])[1]), reverse=True)\n        group2 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 3], key=lambda t: int(str(t.name[5:7])[1]))\n        return group1 + group2",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_curve",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_curve(teeth, name):\n    def sort_upper(teeth):\n        group1 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 1], key=lambda t: int(str(t.name[5:7])[1]), reverse=True)\n        group2 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 2], key=lambda t: int(str(t.name[5:7])[1]))\n        return group1 + group2\n    def sort_lower(teeth):\n        group1 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 4], key=lambda t: int(str(t.name[5:7])[1]), reverse=True)\n        group2 = sorted([t for t in teeth if int(str(t.name[5:7])[0]) == 3], key=lambda t: int(str(t.name[5:7])[1]))\n        return group1 + group2\n    sort_func = sort_upper if \"Upper\" in name else sort_lower",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "duplicate_curve",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def duplicate_curve(curve, length=1, direction_vector=(0, 3, 0, 1)):\n    # Convert direction_vector to Vector if it's not already\n    if not isinstance(direction_vector, Vector):\n        direction_vector = Vector(direction_vector)\n    original_location = curve.location.xyz\n    curve.location = (0, 0, 0)\n    # Duplicate the curve\n    curve_copy = curve.copy()\n    curve_copy.data = curve.data.copy()  # Duplicate curve data\n    bpy.context.collection.objects.link(curve_copy)  # Add duplicate to the scene",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "add_teeth_to_armature",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def add_teeth_to_armature(armature, list_of_tooth_number, offset=2, name=\"\", remove_original_bones=True):\n    # Set the armature as the active object and enter Edit mode\n    bpy.context.view_layer.objects.active = armature\n    bpy.ops.object.mode_set(mode='EDIT')\n    # Create a list of the initial bones\n    initial_bones = list(armature.data.edit_bones)\n    new_bones = []\n    tooth_ind = 0\n    for i, bone in enumerate(initial_bones):\n        # Process both the head and tail of the bone for the last bone,",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_armature_from_skin",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_armature_from_skin(obj):\n    bpy.context.view_layer.objects.active = obj\n    bpy.ops.object.mode_set(mode='OBJECT')\n    bpy.ops.object.select_all(action='DESELECT')\n    obj.select_set(True)\n    bpy.ops.object.skin_armature_create(modifier=\"Skin\")\n    # Get the last added object, which should be the armature\n    armature_object = bpy.context.scene.objects[-1]\n    # Check if the added object is actually an armature\n    if not isinstance(armature_object.data, bpy.types.Armature):",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "add_points_to_curve_copy",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def add_points_to_curve_copy(curve, offset=2, name=\"\"):\n    # Create a new curve object\n    curve_data = bpy.data.curves.new('curve_copy', 'CURVE')\n    curve_copy = bpy.data.objects.new('curve_copy', curve_data)\n    bpy.context.collection.objects.link(curve_copy)\n    # Create a single spline\n    spline = curve_data.splines.new('POLY')\n    num_points = len(curve.data.splines[0].points) * 2 - 1\n    spline.points.add(num_points - 1)  # Add the required number of points\n    # Create a list of the initial points",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "create_curves_for_teeth_bones",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def create_curves_for_teeth_bones(armature):\n    # Create a dictionary to store the curves\n    curves = {}\n    # Iterate over the bones in the armature\n    for bone in armature.data.bones:\n        # Only process bones with names ending in \"_tooth\"\n        # if \"_tooth\" in bone.name:\n            # Create a new curve data and object\n            curve_data = bpy.data.curves.new(bone.name + '_curve', 'CURVE')\n            curve_obj = bpy.data.objects.new(bone.name + '_curve', curve_data)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "convert_curve_to_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def convert_curve_to_mesh(curve, name, list_of_tooth_number, thickness_jaw):\n    # Duplicate the curve\n    curve_copy = curve.copy()\n    curve_copy.data = curve.data.copy()  # Duplicate curve data\n    bpy.context.collection.objects.link(curve_copy)  # Add duplicate to the scene\n    # Convert the curve to a mesh\n    bpy.ops.object.select_all(action='DESELECT')\n    curve.select_set(True)\n    bpy.context.view_layer.objects.active = curve\n    bpy.ops.object.mode_set(mode='EDIT') ",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "add_jaw_modifier",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def add_jaw_modifier(obj, skin_thickness=19):\n    skin_modifier = obj.modifiers.new('Skin', 'SKIN')\n    bpy.context.object.data.use_auto_texspace = False\n    bpy.context.object.data.texspace_size[0] = skin_thickness\n    bpy.context.object.data.texspace_size[1] = skin_thickness\n    # Set all points in the curve to use this skin size\n    bpy.ops.object.mode_set(mode='EDIT')\n    bpy.ops.mesh.select_all(action='SELECT')\n    bpy.ops.transform.skin_resize(value=(skin_thickness, skin_thickness, skin_thickness))\n    bpy.ops.object.mode_set(mode='OBJECT')",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_smooth",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def apply_smooth(obj, factor=2.0, repeat=3):\n    apply_all_modifiers(obj)\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Set the active object to the mesh object\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    # Add the Smooth modifier\n    smooth_mod = obj.modifiers.new(name=\"Smooth\", type='SMOOTH')\n    # Set the smooth factor",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "generate_shape_key",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def generate_shape_key(mesh_obj, armature_obj, target_curve, deformation_curve, position, index, logarithmic_curve=False, max_distance=1.8, base=2.0):\n    # Store the scale values of the original bones\n    original_bone_scales = {bone: bone.scale.copy() for bone in armature_obj.pose.bones}\n    # Duplicate the mesh object and its armature\n    bpy.ops.object.select_all(action='DESELECT')\n    mesh_obj.select_set(True)\n    armature_obj.select_set(True)\n    bpy.ops.object.duplicate(linked=False)\n    # Get the duplicated mesh and armature\n    duplicated_mesh = bpy.context.selected_objects[0]",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "extract_number",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def extract_number(tooth):\n    # Split the tooth name by 'Tooth' and '_0' to get the number\n    number = int(str(tooth.name.split('Tooth')[1].split('_0')[0])[1])\n    return number\ndef get_next_filename(directory, base_filename, extension):\n    counter = 0\n    while True:\n        path = os.path.join(directory, f\"{base_filename}_{counter}.{extension}\")\n        if not os.path.exists(path):\n            return path",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "get_next_filename",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def get_next_filename(directory, base_filename, extension):\n    counter = 0\n    while True:\n        path = os.path.join(directory, f\"{base_filename}_{counter}.{extension}\")\n        if not os.path.exists(path):\n            return path\n        counter += 1\ndef calculate_rotation(obj, limit=0.1):\n    # Sort vertices based on y-value\n    sorted_vertices = sorted(obj.data.vertices, key=lambda v: v.co.y)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "calculate_rotation",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def calculate_rotation(obj, limit=0.1):\n    # Sort vertices based on y-value\n    sorted_vertices = sorted(obj.data.vertices, key=lambda v: v.co.y)\n    # Calculate the 5% index\n    percent_index = int(len(sorted_vertices) * limit)\n    # Get the 5% highest and lowest vertices\n    highest_vertices = sorted_vertices[-percent_index:]\n    lowest_vertices = sorted_vertices[:percent_index]\n    # Calculate the average location of these vertices\n    highest_point = [0, 0, 0]",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "calculate_offset",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def calculate_offset(obj, offset, cube_height, displacement_offset=3):\n    # Sort vertices based on z-value depending on the object name\n    if \"Upper\" in obj.name or \"Maxilla\" in obj.name:\n        sorted_vertices = sorted(obj.data.vertices, key=lambda v: v.co.z)\n    elif \"Lower\" in obj.name or \"Mandible\" in obj.name:\n        sorted_vertices = sorted(obj.data.vertices, key=lambda v: v.co.z, reverse=True)\n    # Calculate the offset vertex index\n    offset_index = int((len(sorted_vertices)-1) * (1 - offset))\n    # Calculate the cube location based on the object name and the cube's height\n    if \"Upper\" in obj.name or \"Maxilla\" in obj.name:",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "setup_armature_deformation",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def setup_armature_deformation(mesh_obj, armature_obj, curve_copy):\n    # Move the armature depending on the object name\n    armature_obj.location.z = mesh_obj.location.z\n    # Select the mesh object\n    bpy.context.view_layer.objects.active = mesh_obj\n    mesh_obj.select_set(True)\n    # Add the Armature modifier\n    armature_modifier = mesh_obj.modifiers.new('Armature_Deform', 'ARMATURE')\n    armature_modifier.object = armature_obj\n    # Reselect the mesh object and the armature object",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "setup_teeth_deformation",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def setup_teeth_deformation(mesh_obj, armature_obj, use_actual_armature=False):\n    # Move the armature depending on the object name\n    armature_obj.location.z = mesh_obj.location.z\n    # Select the mesh object\n    bpy.context.view_layer.objects.active = mesh_obj\n    mesh_obj.select_set(True)\n    if not use_actual_armature:\n        # Add the Armature modifier\n        armature_modifier = mesh_obj.modifiers.new('Armature_Deform', 'ARMATURE')\n        armature_modifier.object = armature_obj",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "scale_bones",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def scale_bones(armature_obj, scale_factor=[0, 0], list_of_bones=[], find_by_names=[]):\n    # Ensure we're in object mode\n    bpy.ops.object.mode_set(mode='OBJECT')\n    # Deselect all\n    bpy.ops.object.select_all(action='DESELECT')\n    # Set the active object to the armature object\n    bpy.context.view_layer.objects.active = armature_obj\n    armature_obj.select_set(True)\n    # Switch to pose mode to adjust the bones\n    bpy.ops.object.mode_set(mode='POSE')",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "compute_distances",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def compute_distances(spline, list_of_names=[], teeth=[], by_distance=3.5):\n    # Initialize the list of distances\n    distances = {}\n    # Get the list of points in the spline\n    points = spline.data.splines[0].points\n    # Iterate over the points in the spline, skipping the first and last points\n    for i in range(len(points)):\n        if(teeth[i-1].name[5:7] in list_of_names): \n            distances[i] = teeth[i-1].name[5:7]\n    for i in range(1, len(points) - 1):",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "move_bones",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def move_bones(curve_dict, vector=(0, 0, 0), list_of_bones=[0, -1]):\n    list_of_key_for_curves = list(curve_dict.keys())\n    # list_of_key_for_curves = sorted(list_of_key_for_curves)\n    # Set the active object to the armature object\n    for i in list_of_bones:\n        curve_key = list_of_key_for_curves[i]\n        curve = curve_dict[curve_key]\n        # Ensure we're in object mode\n        bpy.ops.object.mode_set(mode='OBJECT')\n        # Deselect all",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "cut_model",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def cut_model(obj, voxel_level= 0.5, offset=0.25):\n    apply_all_modifiers(obj)\n    # Calculate cube dimensions and add it\n    cube_height = 10\n    cube_location = (0, 0, calculate_offset(obj, offset, cube_height))\n    # cube_rotation = (calculate_rotation(obj), 0, 0)\n    cube_rotation = (0, 0, 0)\n    bpy.ops.mesh.primitive_cube_add(size=1, location=cube_location, rotation=cube_rotation)\n    cube = bpy.context.active_object\n    cube.scale = (100, 100, cube_height)",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_shrinkwrap_and_join_as_shapes",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def apply_shrinkwrap_and_join_as_shapes(base_object, objects, output_object_name, export_path):\n    bpy.context.view_layer.objects.active = base_object\n    last_modified_object = None\n    new_objects = []\n    for obj_key in sorted(objects.keys(), key=lambda name: int(name)):\n        obj = objects[obj_key]\n        # Copy the base object\n        copy = base_object.copy()\n        copy.data = base_object.data.copy()  # Also duplicate the mesh data\n        copy.name = f\"{base_object.name}_{obj_key}\"  # Naming the copy as per requirement",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "generateJaw",
        "kind": 2,
        "importPath": "lib.optimize.generateJaw",
        "description": "lib.optimize.generateJaw",
        "peekOfCode": "def generateJaw(folder_path, export_path='./', jaw_type=\"Upper\"):\n     # Vérifie si le paramètre jaw_type est correct\n    if jaw_type not in [\"Upper\", \"Lower\"]:\n        print(\"Error: jaw_type must be either 'Upper' or 'Lower'\")\n        return\n    # Delete all objects in the scene\n    bpy.ops.object.select_all(action='SELECT')\n    bpy.ops.object.delete()\n    z_adjustement = 6\n    scale_adjustement = 0.05",
        "detail": "lib.optimize.generateJaw",
        "documentation": {}
    },
    {
        "label": "apply_decimate",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_decimate(obj, ratio=1, decimate_type='COLLAPSE'):\n    \"\"\"\n    Applique un modificateur Decimate à l'objet donné avec les paramètres spécifiés.\n    \"\"\"\n    if obj is None:\n        print(\"Aucun objet actif pour appliquer Decimate.\")\n        return\n    # S'assurer que Blender est en mode objet et que l'objet est sélectionné et actif\n    bpy.context.view_layer.objects.active = obj  # Définir l'objet comme actif\n    if bpy.context.active_object.mode != 'OBJECT':",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "load_and_rename_objects",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def load_and_rename_objects(dossier_racine, detail_levels):\n    etapes = []\n    list_fichiers_a_supprimer = []\n    list_fichiers_non_lowpolisables = []\n    nb_etapes = len(os.listdir(dossier_racine))\n    for nom_dossier in sorted(os.listdir(dossier_racine)):\n        chemin_sous_dossier = os.path.join(dossier_racine, nom_dossier)\n        # On vérifie si le nom du dossier est un entier (étape)\n        if os.path.isdir(chemin_sous_dossier) and nom_dossier.isdigit():\n            etape = int(nom_dossier)",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "create_lowpoly_tooth_copies",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def create_lowpoly_tooth_copies(reduction_ratio=0.02, list_fichiers_a_eviter=[], list_fichiers_a_supprimer=[], etape_finale=10):\n    # Désélectionner tous les objets au début pour partir sur une base propre\n    bpy.ops.object.select_all(action='DESELECT')\n    for obj in bpy.data.objects:\n        if obj.type == 'MESH' and \"Tooth\" in obj.name and obj not in list_fichiers_a_eviter:\n            # S'assurer que l'objet de contexte est correctement défini\n            bpy.context.view_layer.objects.active = obj\n            # Sélectionner l'objet original\n            obj.select_set(True)\n            # Dupliquer l'objet",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "apply_select_and_deform",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_select_and_deform(obj_name, fichier):\n    if \"Mandible\" in fichier:\n        select_and_deform(obj_name, fromDirection=-1)\n    elif \"Maxilla\" in fichier:\n        select_and_deform(obj_name, fromDirection=1)\ndef select_and_deform(obj_name, fromDirection=1, offset=1, translation_strength=1, iterations=4):\n    obj = bpy.data.objects[obj_name]\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    bpy.ops.object.mode_set(mode='EDIT')",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "select_and_deform",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def select_and_deform(obj_name, fromDirection=1, offset=1, translation_strength=1, iterations=4):\n    obj = bpy.data.objects[obj_name]\n    bpy.context.view_layer.objects.active = obj\n    obj.select_set(True)\n    bpy.ops.object.mode_set(mode='EDIT')\n    bm = bmesh.from_edit_mesh(obj.data)\n    y_coords = [v.co.y for v in bm.verts]  # Utiliser les coordonnées y\n    max_y = max(y_coords)  # Max de y\n    min_y = min(y_coords)  # Min de y\n    target_y = max_y if fromDirection == 1 else min_y  # Cibler sur y",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "export_all_to_glb",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def export_all_to_glb(file_path, with_blender_data=False, compression_level=6):\n    \"\"\"\n    Exporte tous les objets de la scène au format GLB avec la compression spécifiée.\n    :param file_path: Chemin complet du fichier de sortie GLB.\n    :param compression_level: Niveau de compression (0 à 10).\n    \"\"\"\n    if(with_blender_data):\n        bpy.ops.export_scene.gltf(\n            filepath=file_path,\n            export_format='GLB',  # Choisir le format GLB pour le fichier de sortie",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "apply_smooth_shading_to_all_objects",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_smooth_shading_to_all_objects():\n    for obj in bpy.data.objects:\n        if obj.type == 'MESH':\n            bpy.context.view_layer.objects.active = obj\n            bpy.ops.object.select_all(action='DESELECT')  # Désélectionner tous les objets\n            obj.select_set(True)\n            bpy.ops.object.shade_smooth()\ndef get_opposite_arcs(arch_digit):\n    \"\"\"\n    Retourne les arcades opposées sous forme de liste.",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "get_opposite_arcs",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def get_opposite_arcs(arch_digit):\n    \"\"\"\n    Retourne les arcades opposées sous forme de liste.\n    Haut = 1, 2\n    Bas = 3, 4\n    Si la dent est du haut (1 ou 2), opposées = [3,4]\n    Si la dent est du bas (3 ou 4), opposées = [1,2]\n    \"\"\"\n    arch_digit = int(arch_digit)\n    if arch_digit in [1, 2]:",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "get_object_center",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def get_object_center(obj):\n    # Centre approximatif = moyenne des coords des vertices en coordonnées monde\n    verts = obj.data.vertices\n    if not verts:\n        return obj.matrix_world.translation\n    sum_coord = Vector((0,0,0))\n    for v in verts:\n        sum_coord += obj.matrix_world @ v.co\n    return sum_coord / len(verts)\ndef is_point_inside_mesh(point, bvhtree, max_tests=50, offset=1e-6):",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "is_point_inside_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def is_point_inside_mesh(point, bvhtree, max_tests=50, offset=1e-6):\n    \"\"\"\n    Vérifie si un point est à l'intérieur d'une géométrie représentée par un BVHTree.\n    Méthode : lancers de rayons dans une direction fixe (ex: +X) et comptage des intersections.\n    \"\"\"\n    direction = mathutils.Vector((1, 0, 0))\n    hit_count = 0\n    start = point.copy()\n    for _ in range(max_tests):\n        hit = bvhtree.ray_cast(start, direction)",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "check_teeth_vertex_count_consistency",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def check_teeth_vertex_count_consistency(debug=True):\n    \"\"\"\n    Parcourt tous les objets 'Tooth_XX_step' dans la scène\n    et vérifie si, pour un même 'XX' (ex: 11), le nombre de vertex\n    est identique d'une étape à l'autre.\n    Si on détecte un mismatch, on l'affiche et on renvoie un dict\n    indiquant les incohérences.\n    Retourne un dict:\n      mismatches = {\n        \"Tooth_11\": {",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "fix_teeth_vertex_count_mismatch",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def fix_teeth_vertex_count_mismatch(debug=True):\n    \"\"\"\n    Parcourt tous les objets 'Tooth_XX_step' dans la scène\n    et tente de corriger un mismatch de vertex count d'une étape à l'autre\n    en dupliquant ou supprimant des sommets (très rudimentaire).\n    -> On choisit l'étape 0 comme référence.\n    -> Si la dent Tooth_XX_0 existe et qu'à l'étape i,\n       on a un count différent, on corrige la topologie de l'étape i\n       pour le ramener au count de l'étape 0.\n    \"\"\"",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "load_transformation_data",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def load_transformation_data(temp_data_path):\n    \"\"\"\n    Lit temp_data.json et renvoie un dict:\n    transform_data[step][toothName] = matrice 4x4 (mathutils.Matrix).\n    \"\"\"\n    with open(temp_data_path, 'r') as f:\n        data = json.load(f)\n    result = {}\n    # data[\"transformationTooth\"] contient toutes les étapes\n    transformation_dict = data[\"transformationTooth\"]  # ex: { \"0\": {...}, \"1\": {...}, ... }",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "get_opposite_arcs",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def get_opposite_arcs(arch_digit):\n    \"\"\"1,2 => [3,4], 3,4 => [1,2].\"\"\"\n    a = int(arch_digit)\n    return [3,4] if a in [1,2] else [1,2]\ndef build_bvhtree_for_teeth(list_objs):\n    \"\"\"Construit un unique BVH en coords monde pour tous les objets listés.\"\"\"\n    if not list_objs:\n        return None\n    all_tris=[]\n    import bmesh",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "build_bvhtree_for_teeth",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def build_bvhtree_for_teeth(list_objs):\n    \"\"\"Construit un unique BVH en coords monde pour tous les objets listés.\"\"\"\n    if not list_objs:\n        return None\n    all_tris=[]\n    import bmesh\n    for ob in list_objs:\n        mw = ob.matrix_world\n        me = ob.data\n        bm = bmesh.new()",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "is_point_inside_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def is_point_inside_mesh(point, bvhtree, max_tests=50, offset=1e-5):\n    \"\"\"Test odd/even => rayon +X, compte intersections.\"\"\"\n    from mathutils import Vector\n    if not bvhtree:\n        return False\n    direction = Vector((1,0,0))\n    start = point.copy()\n    hits=0\n    for _ in range(max_tests):\n        cast=bvhtree.ray_cast(start, direction)",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "apply_colors_to_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_colors_to_mesh(obj, color_array):\n    \"\"\"Applique color_array à OcclusionColors de obj.\"\"\"\n    me=obj.data\n    if \"OcclusionColors\" not in me.vertex_colors:\n        vc=me.vertex_colors.new(name=\"OcclusionColors\")\n    else:\n        vc=me.vertex_colors[\"OcclusionColors\"]\n    for loop in me.loops:\n        i=loop.vertex_index\n        c=color_array[i]",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "get_center_world",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def get_center_world(obj):\n    \"\"\"Centre en coords monde (moyenne des vertices).\"\"\"\n    if not obj.data.vertices:\n        return obj.matrix_world.translation\n    from mathutils import Vector\n    s=Vector((0,0,0))\n    for v in obj.data.vertices:\n        s+= (obj.matrix_world @ v.co)\n    return s/len(obj.data.vertices)\ndef reset_all_teeth_to_identity():",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "reset_all_teeth_to_identity",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def reset_all_teeth_to_identity():\n    \"\"\"Remet la matrix_world de tous les 'ToothXX_0' à la matrice identité.\"\"\"\n    for obj in bpy.data.objects:\n        if obj.type=='MESH' and obj.name.startswith(\"Tooth\") and obj.name.endswith(\"_0\"):\n            # reset\n            obj.matrix_world = Matrix.Identity(4)\ndef calculate_occlusion_via_temp_data(temp_data_path, \n                                      red_threshold=0.2,\n                                      green_threshold=0.5,\n                                      debug=False):",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "calculate_occlusion_via_temp_data",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def calculate_occlusion_via_temp_data(temp_data_path, \n                                      red_threshold=0.2,\n                                      green_threshold=0.5,\n                                      debug=False):\n    \"\"\"\n    Calcule l'occlusion pour chaque étape listée dans temp_data.json.\n    Hypothèses:\n     - Les dents de base s'appellent \"Tooth_XX_0\" (ex: \"Tooth_14_0\").\n       => On en extrait \"14\" pour base_teeth_map[\"14\"] = <OBJ>.\n     - Dans temp_data.json, on a transform_data[step][\"Tooth_14\"] = matrice",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "apply_colors_to_mesh",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_colors_to_mesh(obj, tooth_colors):\n    \"\"\"\n    Applique les couleurs calculées directement dans l'attribut vertex_colors du mesh Blender.\n    Ceci garantit que l'export GLB inclura les couleurs, et que l'ordre des vertices sera préservé.\n    \"\"\"\n    me = obj.data\n    # S'assurer qu'il n'y a pas déjà un attribut \"OcclusionColors\" ou le recréer\n    if \"OcclusionColors\" in me.vertex_colors:\n        color_layer = me.vertex_colors[\"OcclusionColors\"]\n    else:",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "assign_vertex_id_to_blender_data",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def assign_vertex_id_to_blender_data(blender_data, max_verts):\n    \"\"\"\n    Assigne un attribut vertex_id et stocke les indices originaux des sommets dans blender_data.\n    La structure sera similaire à celle d'occlusionData, avec l'étape comme clé de niveau 1,\n    puis le nom complet de la dent (ex: \"Tooth_11\") comme clé de niveau 2.\n    Structure finale:\n    blender_data[\"VertexIDMap\"][step][obj_name] = [liste de vertex_id_norm]\n    \"\"\"\n    if \"VertexIDMap\" not in blender_data:\n        blender_data[\"VertexIDMap\"] = {}",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "store_original_positions",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def store_original_positions():\n    original_positions = {}\n    for obj in bpy.data.objects:\n        if obj.type=='MESH' and \"Tooth_\" in obj.name and obj.name.endswith(\"_0\"):\n            parts = obj.name.split(\"_\")\n            if len(parts) < 3:\n                continue\n            tooth_name = f\"Tooth_{parts[1]}\"\n            if not obj.data.vertices:\n                original_positions[tooth_name] = []",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "remap_occlusion_data_according_to_positions",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def remap_occlusion_data_according_to_positions(blender_data, original_positions, debug=True):\n    if debug:\n        print(\"\\n--- Début du remapping ---\")\n    # Vérifier la présence des données d'occlusion\n    if \"OcclusionData\" not in blender_data:\n        if debug:\n            print(\"[ERREUR] Aucune donnée d'occlusion trouvée dans blender_data.\")\n        return\n    occlusion_data = blender_data[\"OcclusionData\"]\n    # On récupère la liste de toutes les étapes disponibles",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "store_blender_data_in_scene",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def store_blender_data_in_scene(blender_data):\n    \"\"\"\n    Mettre 'blender_data' dans les propriétés de la scène\n    afin que l'export glTF l'intègre dans scene[\"extras\"].\n    \"\"\"\n    # Réduction de la précision des données\n    optimized_data = reduce_precision(blender_data)\n    # Convertir en JSON compact\n    scene = bpy.context.scene\n    scene[\"blender_data_json\"] = json.dumps(optimized_data, separators=(',', ':'))",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "reduce_precision",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def reduce_precision(data, precision=3):\n    \"\"\"\n    Réduit la précision des nombres dans une structure de données imbriquée.\n    \"\"\"\n    if isinstance(data, float):\n        return round(data, precision)\n    elif isinstance(data, list):\n        return [reduce_precision(item, precision) for item in data]\n    elif isinstance(data, dict):\n        return {key: reduce_precision(value, precision) for key, value in data.items()}",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "export_blender_data",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def export_blender_data(blender_data, export_directory, blender_data_file):\n    data = reduce_precision(blender_data, 3)\n    # # Convertir les données en MessagePack\n    # packed_data = msgpack.packb(data, use_bin_type=True)\n    packed_data = msgpack.packb(data, use_bin_type=True)\n    # Compresser avec zlib\n    compressed_data = zlib.compress(packed_data, level=9)  # level=9 => compression maximale\n    # Nom de fichier de sortie (avec extension personnalisée)\n    output_path = os.path.join(export_directory, blender_data_file)  \n    # Écriture binaire du fichier compressé",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "allInOneGLB",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def allInOneGLB(optimized_directory, export_directory, blender_data_file):\n    \"\"\"\n    1) Nettoyer la scène\n    2) Charger / renommer / decimate\n    3) (Facultatif) Calcul occlusion\n    4) Calculer la sectorisation => sur Tooth_XX_{last_step}, sans scale local\n    5) Stocker positions d'origine (avant compression) pour gencive + dents\n    6) Export en GLB Draco\n    7) Purge la scène, réimport\n    8) Remapping => occlusion, gencive, dents",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "assign_gum_vertices_to_closest_tooth",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def assign_gum_vertices_to_closest_tooth(blender_data, debug=True):\n    \"\"\"\n    Assigne chaque vertex de la gencive à la dent la plus proche en termes de topologie et de centroïde.\n    Si un vertex est plus proche d'une autre dent, il est supprimé de l'indexMap de la dent actuelle\n    et assigné à la dent voisine.\n    Cette version intègre des seuils de distance pour éviter les influences indésirables des dents voisines.\n    Paramètres:\n    - blender_data: dictionnaire contenant 'jawSectorisation' et autres données.\n    - debug: booléen, si True, affiche des informations de débogage.\n    \"\"\"",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "add_neighbour_weights_to_sectorization",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def add_neighbour_weights_to_sectorization(blender_data, debug=True, num_top_neighbors=3):\n    \"\"\"\n    Ajoute 'closestToothDataNeighbourWeight' à chaque vertex dans 'jawSectorisation'.\n    Cette version calcule les poids en considérant la distance au centroid de la dent actuelle\n    et aux centroides des dents voisines les plus proches, avec une normalisation pour permettre\n    une répartition complète des poids de 0 à 1.\n    Paramètres:\n    - blender_data: dictionnaire contenant 'jawSectorisation' et autres données.\n    - debug: booléen, si True, affiche des informations de débogage.\n    - num_top_neighbors: nombre de dents voisines les plus proches à considérer pour le calcul des poids.",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "remap_neighbour_weights_after_compression",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def remap_neighbour_weights_after_compression(blender_data, original_positions, debug=True):\n    \"\"\"\n    Remappe 'closestToothDataNeighbourWeight' dans 'jawSectorisation' après compression.\n    Cette fonction doit être appelée après 'remap_teeth_in_sectorisation' pour mettre à jour les poids\n    basés sur les nouvelles positions.\n    Elle recalcul les poids en fonction des nouvelles positions des dents et des vertices de la gencive.\n    Paramètres:\n    - blender_data: dictionnaire contenant 'jawSectorisation' et autres données.\n    - original_positions: dictionnaire contenant les positions originales des vertices des dents avant compression.\n    - debug: booléen, si True, affiche des informations de débogage.",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "remap_teeth_in_sectorisation",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def remap_teeth_in_sectorisation(blender_data, original_teeth_positions, debug=True):\n    \"\"\"\n    Remappe, pour chaque dent *référencée par tooth_number*, \n    le champ meshIndex dans blender_data[\"jawSectorisation\"][tooth_number][\"indexMap\"].\n    On s'appuie sur l'étape 0 comme référence :\n     - original_teeth_positions[\"Tooth_11\"] = liste de positions AVANT compression (étape 0).\n     - l'objet compressé post-Draco => \"Tooth_11_0\".\n    On reconstruit un mapping : new_index -> old_index, \n    puis on applique ce mapping pour chaque \"tooth_number\" \n    dans la sectorisation.",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "store_original_teeth_positions_for_sectorisation",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def store_original_teeth_positions_for_sectorisation(last_step=None, debug=True):\n    \"\"\"\n    Stocke les positions *avant compression* des dents 'Tooth_XX_{last_step}',\n    c'est-à-dire la dent d'origine, non lowpoly.\n    Retourne un dict: { \"Tooth_11_5\": [Vector(...), ...], ... }\n    \"\"\"\n    import bpy\n    from mathutils import Vector\n    original_positions = {}\n    for obj in bpy.data.objects:",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "generate_jaw_sectorisation_using_clones",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def generate_jaw_sectorisation_using_clones(blender_data, \n                                            temp_data_path, \n                                            debug=True):\n    \"\"\"\n    1) Charge transform_data = load_transformation_data(temp_data_path).\n    2) Détermine la plus grande étape last_step = max des clés de transform_data.\n    3) Récupère transform_data[last_step] = { \"Tooth_14\": matrix, \"Tooth_11\": matrix, ... }\n       et construit un dictionnaire last_step_matrices[\"14\"] = matrix, etc.\n    4) Récupère toutes les dents de base \"Tooth_XX_0\", clone + applique matrix => geometry \"dernière étape\".\n    5) Calcule la sectorisation (stacked spheres + top_center à +2.0 en local Y).",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "generate_jaw_sectorisation_using_clones_parallel",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def generate_jaw_sectorisation_using_clones_parallel(blender_data, \n                                                     temp_data_path, \n                                                     debug=True):\n    \"\"\"\n    Variante parallèle de la fonction generate_jaw_sectorisation_using_clones.\n    L'idée est de limiter l'accès direct à bpy.data ou aux ops Blender\n    dans les parties parallélisées. Seules les données \"pures\" (listes \n    de coordonnées de vertex, matrices, etc.) sont manipulées en parallèle.\n    \"\"\"\n    # -- 0) Vérification / initialisation du dictionnaire",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "calculate_centroids",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def calculate_centroids(blender_data, debug=True):\n    \"\"\"\n    Calcule les centroides de chaque dent en utilisant le centre géométrique de leur BufferGeometry.\n    Paramètres:\n    - blender_data: dictionnaire contenant 'jawSectorisation' et autres données.\n    - debug: booléen, si True, affiche des informations de débogage.\n    Retourne:\n    - tooth_centroids: dictionnaire mappant chaque dent à son centroid.\n    \"\"\"\n    import bpy",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "apply_transforms_after_import",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def apply_transforms_after_import(debug=False):\n    bpy.ops.object.select_all(action='DESELECT')\n    for obj in bpy.data.objects:\n        if obj.type == 'MESH':\n            obj.select_set(True)\n            bpy.context.view_layer.objects.active = obj\n            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)\n            obj.select_set(False)\n    if debug:\n        print(\"[apply_transforms_after_import] Done.\")",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "remap_jaw_sectorisation",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def remap_jaw_sectorisation(blender_data, original_jaw_positions, debug=True):\n    \"\"\"\n    Remap les indices de blender_data[\"jawSectorisation\"] en fonction de la topologie\n    réelle après compression (Draco). Le principe :\n      - On construit un KDTree pour Maxilla_0 (nouvelle topologie),\n        à partir de l'OBJ/GLTF compressé désormais présent en scène.\n      - Idem pour Mandible_0.\n      - Pour chaque index 'old_index' qui figure dans jawSectorisation (vertexIndices/indexMap),\n        on retrouve l'index 'new_index' correspondant dans la nouvelle topologie.\n      - On réécrit vertexIndices et indexMap en conséquence.",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "store_original_jaw_positions",
        "kind": 2,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "def store_original_jaw_positions():\n    \"\"\"\n    Récupère les positions d'origine des sommets de Maxilla_0 et Mandible_0.\n    Retourne un dict:\n    {\n      \"Maxilla_0\": [Vector(...), Vector(...)...],\n      \"Mandible_0\": [Vector(...), Vector(...)...]\n    }\n    \"\"\"\n    original_jaw_positions = {",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "detail_levels",
        "kind": 5,
        "importPath": "lib.optimize.generateMouthGLB",
        "description": "lib.optimize.generateMouthGLB",
        "peekOfCode": "detail_levels = {\n    \"Mandible\": (1, 'COLLAPSE'),\n    \"Maxilla\": (1, 'COLLAPSE'),\n    \"Tooth\": (0.5, 'COLLAPSE'),\n    \"attachment\": (1, 'COLLAPSE') \n}\ndef apply_decimate(obj, ratio=1, decimate_type='COLLAPSE'):\n    \"\"\"\n    Applique un modificateur Decimate à l'objet donné avec les paramètres spécifiés.\n    \"\"\"",
        "detail": "lib.optimize.generateMouthGLB",
        "documentation": {}
    },
    {
        "label": "datas",
        "kind": 5,
        "importPath": "lib.optimize.hook-pymeshlab",
        "description": "lib.optimize.hook-pymeshlab",
        "peekOfCode": "datas = collect_data_files(\"pymeshlab\")\nbinaries = collect_dynamic_libs(\"pymeshlab\")",
        "detail": "lib.optimize.hook-pymeshlab",
        "documentation": {}
    },
    {
        "label": "binaries",
        "kind": 5,
        "importPath": "lib.optimize.hook-pymeshlab",
        "description": "lib.optimize.hook-pymeshlab",
        "peekOfCode": "binaries = collect_dynamic_libs(\"pymeshlab\")",
        "detail": "lib.optimize.hook-pymeshlab",
        "documentation": {}
    },
    {
        "label": "input_data_path",
        "kind": 5,
        "importPath": "lib.optimize.landmarks",
        "description": "lib.optimize.landmarks",
        "peekOfCode": "input_data_path = 'input_data'\nlandmark_filename = 'landmarks Txt.txt'\nlandmark_filepath = os.path.join(input_data_path, landmark_filename)\nwith open(landmark_filepath) as f:\n    lines = f.readlines()\nlandmarks = {}\nfor line in lines:\n    toothId = 0\n    if line[0:2].isdigit() :\n        toothId = line[0:2]",
        "detail": "lib.optimize.landmarks",
        "documentation": {}
    },
    {
        "label": "landmark_filename",
        "kind": 5,
        "importPath": "lib.optimize.landmarks",
        "description": "lib.optimize.landmarks",
        "peekOfCode": "landmark_filename = 'landmarks Txt.txt'\nlandmark_filepath = os.path.join(input_data_path, landmark_filename)\nwith open(landmark_filepath) as f:\n    lines = f.readlines()\nlandmarks = {}\nfor line in lines:\n    toothId = 0\n    if line[0:2].isdigit() :\n        toothId = line[0:2]\n    elif line[0:2] == 'ap':",
        "detail": "lib.optimize.landmarks",
        "documentation": {}
    },
    {
        "label": "landmark_filepath",
        "kind": 5,
        "importPath": "lib.optimize.landmarks",
        "description": "lib.optimize.landmarks",
        "peekOfCode": "landmark_filepath = os.path.join(input_data_path, landmark_filename)\nwith open(landmark_filepath) as f:\n    lines = f.readlines()\nlandmarks = {}\nfor line in lines:\n    toothId = 0\n    if line[0:2].isdigit() :\n        toothId = line[0:2]\n    elif line[0:2] == 'ap':\n        toothId = line[5:7]",
        "detail": "lib.optimize.landmarks",
        "documentation": {}
    },
    {
        "label": "landmarks",
        "kind": 5,
        "importPath": "lib.optimize.landmarks",
        "description": "lib.optimize.landmarks",
        "peekOfCode": "landmarks = {}\nfor line in lines:\n    toothId = 0\n    if line[0:2].isdigit() :\n        toothId = line[0:2]\n    elif line[0:2] == 'ap':\n        toothId = line[5:7]\n    details = line.split()\n    if toothId != 0 and details[-1][-1] == 'm':\n        if toothId not in landmarks.keys():",
        "detail": "lib.optimize.landmarks",
        "documentation": {}
    },
    {
        "label": "suppress_stdout",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout\ndef compute_rotation(matrix, in_degrees=False):\n    \"\"\"",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "compute_rotation",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def compute_rotation(matrix, in_degrees=False):\n    \"\"\"\n    Calcule la rotation à partir d'une matrice de transformation.\n    :param matrix: matrice de transformation 4x4\n    :param in_degrees: si True, retourne les angles de rotation en degrés, sinon en radians (par défaut)\n    :return: liste contenant les angles de rotation [rx, ry, rz]\n    \"\"\"\n    r = np.zeros(3)\n    if matrix[2, 0] != 1 and matrix[2, 0] != -1:\n        r[1] = -math.asin(matrix[2, 0])",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "parse_obj_file",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def parse_obj_file(obj_file_path):\n    meshes = {}\n    current_mesh_name = None\n    vertices = []\n    with open(obj_file_path, 'r') as f:\n        for line in f:\n            line = line.strip()\n            if line.startswith('g '):  # Nouveau groupe (mesh)\n                current_mesh_name = line[2:].strip()\n                meshes[current_mesh_name] = []",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_centroid",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_centroid(vertices):\n    return np.mean(vertices, axis=0)\ndef calculate_covariance_matrix(vertices, centroid):\n    centered_vertices = vertices - centroid\n    return np.cov(centered_vertices.T)\ndef calculate_principal_axes(covariance_matrix):\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n    return eigenvectors\ndef calculate_rotations_from_axes(principal_axes):\n    # (Utilisez la fonction compute_rotation que vous avez déjà définie)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_covariance_matrix",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_covariance_matrix(vertices, centroid):\n    centered_vertices = vertices - centroid\n    return np.cov(centered_vertices.T)\ndef calculate_principal_axes(covariance_matrix):\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n    return eigenvectors\ndef calculate_rotations_from_axes(principal_axes):\n    # (Utilisez la fonction compute_rotation que vous avez déjà définie)\n    return compute_rotation(principal_axes)\ndef is_valid_object_name(name):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_principal_axes",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_principal_axes(covariance_matrix):\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n    return eigenvectors\ndef calculate_rotations_from_axes(principal_axes):\n    # (Utilisez la fonction compute_rotation que vous avez déjà définie)\n    return compute_rotation(principal_axes)\ndef is_valid_object_name(name):\n    pattern = r'^\\d+:\\s.*'\n    return re.match(pattern, name) is not None\ndef calculate_extent(vertices):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_rotations_from_axes",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_rotations_from_axes(principal_axes):\n    # (Utilisez la fonction compute_rotation que vous avez déjà définie)\n    return compute_rotation(principal_axes)\ndef is_valid_object_name(name):\n    pattern = r'^\\d+:\\s.*'\n    return re.match(pattern, name) is not None\ndef calculate_extent(vertices):\n    min_coords = np.min(vertices, axis=0)\n    max_coords = np.max(vertices, axis=0)\n    extent = max_coords - min_coords",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "is_valid_object_name",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def is_valid_object_name(name):\n    pattern = r'^\\d+:\\s.*'\n    return re.match(pattern, name) is not None\ndef calculate_extent(vertices):\n    min_coords = np.min(vertices, axis=0)\n    max_coords = np.max(vertices, axis=0)\n    extent = max_coords - min_coords\n    return extent\ndef calculate_max_length(extent):\n    return np.max(extent)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_extent",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_extent(vertices):\n    min_coords = np.min(vertices, axis=0)\n    max_coords = np.max(vertices, axis=0)\n    extent = max_coords - min_coords\n    return extent\ndef calculate_max_length(extent):\n    return np.max(extent)\ndef create_bounding_box(centroid, max_length):\n    half_length = max_length / 2\n    min_coords = centroid - half_length",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_max_length",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_max_length(extent):\n    return np.max(extent)\ndef create_bounding_box(centroid, max_length):\n    half_length = max_length / 2\n    min_coords = centroid - half_length\n    max_coords = centroid + half_length\n    return min_coords, max_coords\ndef calculate_rotation_from_bounding_box(vertices, centroid):\n    covariance_matrix = calculate_covariance_matrix(vertices, centroid)\n    principal_axes = calculate_principal_axes(covariance_matrix)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "create_bounding_box",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def create_bounding_box(centroid, max_length):\n    half_length = max_length / 2\n    min_coords = centroid - half_length\n    max_coords = centroid + half_length\n    return min_coords, max_coords\ndef calculate_rotation_from_bounding_box(vertices, centroid):\n    covariance_matrix = calculate_covariance_matrix(vertices, centroid)\n    principal_axes = calculate_principal_axes(covariance_matrix)\n    rotation_matrix = principal_axes\n    return compute_rotation(rotation_matrix)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_rotation_from_bounding_box",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_rotation_from_bounding_box(vertices, centroid):\n    covariance_matrix = calculate_covariance_matrix(vertices, centroid)\n    principal_axes = calculate_principal_axes(covariance_matrix)\n    rotation_matrix = principal_axes\n    return compute_rotation(rotation_matrix)\ndef calculate_face_normal(vertices):\n    v0, v1, v2 = vertices\n    edge1 = v1 - v0\n    edge2 = v2 - v0\n    normal = np.cross(edge1, edge2)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_face_normal",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_face_normal(vertices):\n    v0, v1, v2 = vertices\n    edge1 = v1 - v0\n    edge2 = v2 - v0\n    normal = np.cross(edge1, edge2)\n    return normal / np.linalg.norm(normal)\ndef calculate_rotation_from_normals(normals):\n    normal_matrix = np.vstack(normals)\n    covariance_matrix = np.cov(normal_matrix.T)\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_rotation_from_normals",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_rotation_from_normals(normals):\n    normal_matrix = np.vstack(normals)\n    covariance_matrix = np.cov(normal_matrix.T)\n    eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)\n    rotation_matrix = eigenvectors\n    return compute_rotation(rotation_matrix)\ndef extract_position_and_rotation(obj_file_path):\n    meshes = parse_obj_file(obj_file_path)\n    positions_and_rotations = {}\n    for name, faces in meshes.items():",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "extract_position_and_rotation",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def extract_position_and_rotation(obj_file_path):\n    meshes = parse_obj_file(obj_file_path)\n    positions_and_rotations = {}\n    for name, faces in meshes.items():\n        if is_valid_object_name(name):\n            vertices = np.vstack([v for face in faces for v in face])\n            centroid = calculate_centroid(vertices)\n            extent = calculate_extent(vertices)\n            max_length = calculate_max_length(extent)\n            min_coords, max_coords = create_bounding_box(centroid, max_length)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "create_position_rotation_dict",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def create_position_rotation_dict(file_paths):\n    position_rotation_dict = {}\n    for path in file_paths:\n        # Extraire le numéro à partir du nom du fichier\n        file_name = os.path.basename(path)\n        step_number = int(re.findall(r'Step(\\d+)', file_name)[0])\n        # Extraire les positions et rotations\n        position_rotation_info = extract_position_and_rotation(path)\n        # Ajouter ou mettre à jour les informations dans le dictionnaire\n        if step_number in position_rotation_dict:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def main(file_in, spt_out, writing=True):\n    splitted_file_names = []\n    v_pat = re.compile(r\"^v\\s[\\s\\S]*\")  # vertex\n    vn_pat = re.compile(r\"^vn\\s[\\s\\S]*\")  # vertex normal\n    f_pat = re.compile(r\"^f\\s[\\s\\S]*\")  # face\n    o_pat = re.compile(r\"^o\\s[\\s\\S]*\")  # named object\n    ml_pat = re.compile(r\"^mtllib[\\s\\S]*\")  # .mtl file\n    mu_pat = re.compile(r\"^usemtl[\\s\\S]*\")  # material to use\n    s_pat = re.compile(r\"^s\\s[\\s\\S]*\")  # shading\n    vertices = ['None']  # because OBJ has 1-based indexing",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "translate_mesh",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def translate_mesh(mesh, translation):\n    mesh.vertices += translation\ndef get_csv_file_paths(directory_path):\n    \"\"\"\n    Scans a directory and returns a list of absolute file paths of CSV files \n    matching the pattern 'StepXX_*.csv' where XX is a digit.\n    Args:\n        directory_path(str): The path of the directory to scan.\n    Returns:\n        file_paths(list): A list of absolute paths of the matched CSV files.",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "get_csv_file_paths",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def get_csv_file_paths(directory_path):\n    \"\"\"\n    Scans a directory and returns a list of absolute file paths of CSV files \n    matching the pattern 'StepXX_*.csv' where XX is a digit.\n    Args:\n        directory_path(str): The path of the directory to scan.\n    Returns:\n        file_paths(list): A list of absolute paths of the matched CSV files.\n    \"\"\"\n    file_paths = []",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "copy_other_objects",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def copy_other_objects(step, obj_folder_path, destination_folder):\n    \"\"\"\n    Copies all .obj files for the given step that are neither pontic teeth nor \"Mandible.obj\" nor \"Maxilla.obj\".\n    Args:\n        step (str): The step to process.\n        obj_folder_path (str): The path to the folder containing the OBJ files.\n        destination_folder (str): The path to the destination folder where the files will be copied.\n        pontic_teeth (dict): Dictionary of pontic teeth for each step.\n    \"\"\"\n    obj_folder_for_step = os.path.join(obj_folder_path, step)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "process_csv_matrix",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def process_csv_matrix(file_paths):\n    \"\"\"\n    Processes a list of CSV files, each containing transformation data for objects.\n    Extracts transformation matrices for objects whose names match the pattern 'XX:*' or 'Tooth XX'\n    where XX is a digit. Stores each transformation matrix in a nested dictionary\n    keyed by step number and attachment number or \"ToothXX\". If multiple attachments with the same \n    number exist, appends an underscore and an index to the attachment number.\n    Args:\n        file_paths(list): A list of absolute paths of the CSV files to process.\n    Returns:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "optimizing_file",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def optimizing_file(file_in_dir,file_out_name, divide_by=0.1):\n  ms = ml.MeshSet()\n  ms.load_new_mesh(file_in_dir) #'out_dir/Mandible.obj'\n  m = ms.current_mesh()\n  # print('input mesh has', m.vertex_number(), 'vertex and', m.face_number(), 'faces')\n  #Target number of vertex\n  TARGET=m.vertex_number()*divide_by\n  #Simplify the mesh. Only first simplification will be agressive\n  while (ms.current_mesh().vertex_number() > TARGET):\n      ms.apply_filter('meshing_decimation_quadric_edge_collapse', preservenormal=True)#, targetfacenum=numFaces, preservenormal=True)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_teeth_structure",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_teeth_structure(list_all,output_json): \n  output_json['upper'] = []\n  output_json['lower'] = []\n  output_json['attach'] = []\n  output_json['quadrant'] = [0,0,0,0]\n  output_json['stages'] = []\n  output_json['fake'] = []\n  for item in list_all:\n    name = item.split('.')[0]\n    name = name.split('_')[0]",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_step_structure",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_step_structure(output_json):\n  step_i = output_json['steps']\n  for i in range(step_i):\n    step_dict = {}\n    step_dict['step'] = i+1\n    step_dict['path'] = '/' + str(i) + '/'\n    step_dict['maxilla'] = 'Maxilla.obj'\n    step_dict['mandible'] = 'Mandible.obj'\n    # The following needs to be calculated\n    step_dict['maxillaMatrix'] = {}",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_highest_files_landmarks",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_highest_files_landmarks(directory):\n    regex = re.compile(r'Step (\\d+) - Landmarks')\n    highest_step = -1\n    files_to_process = \"\"\n    for filename in os.listdir(directory):\n        match = regex.match(filename)\n        if match:\n            step = int(match.group(1))\n            if step > highest_step:\n                highest_step = step",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_highest_step_files_Spacing",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_highest_step_files_Spacing(directory):\n    # Expression régulière pour identifier les fichiers et extraire le numéro de step\n    regex = re.compile(r'Step (\\d+) - Protocol Distances (U|L)\\.csv')\n    highest_step = -1\n    files_to_process = {'U': None, 'L': None}\n    for filename in os.listdir(directory):\n        match = regex.match(filename)\n        if match:\n            step, part = int(match.group(1)), match.group(2)\n            if step > highest_step:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_highest_step_files_IPR",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_highest_step_files_IPR(directory):\n    # Expression régulière pour identifier les fichiers et extraire le numéro de step\n    regex = re.compile(r'Step (\\d+) - Protocol Stripping (U|L)\\.csv')\n    highest_step = -1\n    files_to_process = {'U': None, 'L': None}\n    for filename in os.listdir(directory):\n        match = regex.match(filename)\n        if match:\n            step, part = int(match.group(1)), match.group(2)\n            if step > highest_step:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateIPRdata",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateIPRdata(pathIPR, jsonData, pathUpper=None, pathLower=None):\n    # Initialisation des structures de données\n    iprDataNew = {}\n    for i in range(jsonData['steps']):\n        iprDataNew[i+1] = {'upper': [], 'lower': []}\n    # Traitement du fichier IPR.csv si existant\n    if os.path.exists(pathIPR):\n        with codecs.open(pathIPR, 'rU', 'utf-16') as file:\n            iprReader = csv.reader(file)\n            iprData = process_ipr_file(iprReader)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "process_ipr_file",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def process_ipr_file(iprReader, gumName=None):\n    iprData = {'Maxilla': {'Tooth': [], 'validIprs': {}}, 'Mandible': {'Tooth': [], 'validIprs': {}}}\n    currentGumName = gumName\n    for row in iprReader:\n        # Conversion et nettoyage de la ligne\n        splittedRow = row[0].split('\\t')\n        splittedRow = [item.replace('\"', '').replace('Before ', '') for item in splittedRow]\n        splittedRow = ['0' if item == '' else item for item in splittedRow]\n        # Détermination de la mâchoire concernée si gumName n'est pas spécifié\n        if gumName is None:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "process_spacing_file_separate",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def process_spacing_file_separate(spacingReader, gumName):\n    spacingData = {'Maxilla': {'Tooth': [], 'validSpacings': {}}, 'Mandible': {'Tooth': [], 'validspacings': {}}}\n    currentGumName = gumName\n    for row in spacingReader:\n        splittedRow = row[0].split('\\t')\n        splittedRow = [item.replace('\"', '').replace('Before ', '') for item in splittedRow]\n        splittedRow = ['0' if item == '' else item for item in splittedRow]\n        if 'mm' in splittedRow[0]:\n            spacingData[currentGumName]['Tooth'] = splittedRow[1:]\n        elif 'Step' in splittedRow[0]:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "process_ipr_file_separate",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def process_ipr_file_separate(iprReader, gumName):\n    iprData = {'Maxilla': {'Tooth': [], 'validIprs': {}}, 'Mandible': {'Tooth': [], 'validIprs': {}}}\n    currentGumName = gumName\n    for row in iprReader:\n        splittedRow = row[0].split('\\t')\n        splittedRow = [item.replace('\"', '').replace('Before ', '') for item in splittedRow]\n        splittedRow = ['0' if item == '' else item for item in splittedRow]\n        if 'mm' in splittedRow[0]:\n            iprData[currentGumName]['Tooth'] = splittedRow[1:]\n        elif 'Step' in splittedRow[0]:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateIPRdataSeparate",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateIPRdataSeparate(pathUpper, pathLower, jsonData):\n    print(\"Début de la génération des données IPR séparées...\")\n    iprDataNew = {i+1: {'upper': [], 'lower': []} for i in range(jsonData['steps'])}\n    print(f\"pathUpper, pathLower : {pathUpper}, {pathLower}\")\n    # Traitement du fichier pour la mâchoire supérieure\n    if pathUpper and os.path.exists(pathUpper):\n        print(f\"Traitement du fichier supérieur : {pathUpper}\")\n        try:\n            with codecs.open(pathUpper, 'rU', 'utf-16') as file:\n                iprReader = csv.reader(file)",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "extract_tooth_distances",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def extract_tooth_distances(pathUpper, pathLower):\n    results = []\n    paths = [pathUpper, pathLower]\n    # Trouver les indices des lignes intéressantes\n    teeth_index = 1  # Généralement la seconde ligne contient les noms de dents\n    distances_index = 4  # La cinquième ligne contient les distances\n    for path in paths:\n        print(f\"Traitement du fichier: {path}\")\n        # try:\n        with open(path, 'r', encoding='utf-16') as file:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateTotalMoveData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateTotalMoveData(pathMovementTable, jsonData):\n  movementTable = {}\n  if(os.path.exists(pathMovementTable)):\n    movementReader = csv.reader(codecs.open(pathMovementTable,'rU','utf-16'))\n  else:\n    print((\"The movement Table \", pathMovementTable, \" cannot be found. Skipping generateTotalMoveData\"))\n    logger.error(f\"The movement Table {pathMovementTable}, cannot be found. Skipping generateTotalMoveData\")\n    return jsonData\n  rows = []\n  for row in movementReader:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateToothData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateToothData(jsonData, folderName):\n  locs = ['upper','lower']\n  loc = locs[0]\n  toothData = {}\n  print(\"jsonData['steps']\", jsonData['steps'])\n  print(\"folderName\", folderName)\n  for i in range(jsonData['steps']):\n    print(\"Tooth Data Step : \", i)\n    toothData[i+1] = {} #generating for each step\n    for loc in locs:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "updateJsonIpr",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def updateJsonIpr(jsonData,iprData,toothData):\n  locs = ['upper','lower']\n  # print(toothData)\n  # try:\n  for steps in jsonData['stages']:\n    step = steps['step']\n    for loc in locs:\n      for iprItems in iprData[step][loc]:\n        iprValue = iprItems[2]\n        iprSubscript = str(iprItems[0]) + iprItems[1]",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "didToothMove",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def didToothMove(toothDataStep1, toothDataStep2): #data 1 and data 2 are lists\n  movementOccured = 0\n  for i in range(len(toothDataStep1)):\n    if float(toothDataStep1[i]) != float(toothDataStep2[i]):\n      movementOccured += 1\n  return True if movementOccured > 0 else False\ndef find_highest_totalmovement_files(directory):\n    regex = re.compile(r'Step (\\d+) - Protocol Movement Total (U|L)')\n    highest_step = -1\n    files_to_process = {'U': None, 'L': None}",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_highest_totalmovement_files",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_highest_totalmovement_files(directory):\n    regex = re.compile(r'Step (\\d+) - Protocol Movement Total (U|L)')\n    highest_step = -1\n    files_to_process = {'U': None, 'L': None}\n    for filename in os.listdir(directory):\n        match = regex.match(filename)\n        if match:\n            step, part = int(match.group(1)), match.group(2)\n            if step > highest_step:\n                highest_step = step",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "find_highest_movement_files",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def find_highest_movement_files(directory):\n    regex = re.compile(r'Step (\\d+) - Protocol Movement Step (U|L)')\n    highest_step = -1\n    files_to_process = {'U': None, 'L': None}\n    for filename in os.listdir(directory):\n        match = regex.match(filename)\n        if match:\n            step, part = int(match.group(1)), match.group(2)\n            if step > highest_step:\n                highest_step = step",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "extractMoveDataFromJsonInfoFile",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def extractMoveDataFromJsonInfoFile(jsonData, uncom_files_dir):\n    print(\"Début de extractMoveDataFromJsonInfoFile\")\n    movData = {}\n    totalSteps = jsonData.get('steps', 0)\n    print(f\"Total steps: {totalSteps}\")\n    try:\n        listOfFiles = os.listdir(uncom_files_dir)\n        print(f\"Liste des fichiers dans {uncom_files_dir}: {listOfFiles}\")\n    except Exception as e:\n        print(f\"Erreur lors de la lecture du répertoire {uncom_files_dir}: {e}\")",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateMovDataForSeparatedFiles",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateMovDataForSeparatedFiles(jsonData, uncom_files_dir):\n    movData = {}\n    totalSteps = jsonData['steps']\n    listOfFiles = os.listdir(uncom_files_dir)\n    listOfCSV = [f for f in listOfFiles if f.endswith('.csv')]\n    attachmentData = {}\n    pattern_attachment = re.compile(r'^\\d+:.*$')  # Matches \"XX:\" at the start of the string\n    pattern_tooth = re.compile(r'^Tooth \\d{2}( \\(Copy\\))?$')  # Matches \"Tooth XX\" or \"Tooth XX (Copy)\"\n    transformation_attachments = {}\n    transformation_tooth = {}",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateMovData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateMovData(jsonData, uncom_files_dir):\n  movData = {}\n  totalSteps = jsonData['steps']\n  listOfFiles = os.listdir(uncom_files_dir)\n  listOfCSV = []\n  attchmentData = {}\n  for nameFile in listOfFiles:\n    if (nameFile[len(nameFile)-4:] == '.csv'):\n      listOfCSV.append(nameFile)\n  for i in range(totalSteps):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateLandmarkData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateLandmarkData(input_data_path, landmark_filename, jsonData):\n  landmark_filepath = os.path.join(input_data_path, landmark_filename)\n  if(os.path.exists(landmark_filepath)):\n    with open(landmark_filepath) as f:\n        lines = f.readlines()\n    landmarks = {}\n    for line in lines:\n        toothId = 0\n        if line[0:2].isdigit() :\n            toothId = line[0:2]",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateTotalMoveDataFromSeparatedFiles",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateTotalMoveDataFromSeparatedFiles(uncom_files_dir, jsonData):\n    print(\"Start total movement table calcul from separated files ...\")\n    pathMovementU, pathMovementL = find_highest_totalmovement_files(uncom_files_dir)\n    if pathMovementU and pathMovementL:\n        print(\"Files found:\", pathMovementU, pathMovementL)\n    else:\n        print(\"Warning: Movement total files not found!\")\n        return jsonData\n    movementTable = {}\n    def process_movement_file(path, movementTable, positionString):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateLandmarkDataFromCSV",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateLandmarkDataFromCSV(landmark_filename, jsonData):\n    if os.path.exists(landmark_filename):\n        print(\"Start analysing landmark : \", landmark_filename)\n        df = pd.read_csv(landmark_filename, delimiter='\\t', encoding='utf-16')\n        landmarks = {}\n        # Mapping des suffixes aux points correspondants\n        suffix_to_point = {\n            \"d\": \"Distal point\",\n            \"m\": \"Mesial Point\",\n            \"vMG\": \"Vestibular Gingival\",",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateArcanumMoveData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateArcanumMoveData(jsonData, totalSteps):\n  movData = jsonData[\"movData\"]\n  jsonData[\"movDataByArcanum\"] = {}\n  for step in range(totalSteps):\n    percent = step / totalSteps\n    jsonData[\"movDataByArcanum\"][step] = {\"Lower\": False, \"Upper\": False}\n    for tooth in movData:\n      activityInd = 0\n      for activity in movData[tooth]:\n        result = False",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_aligners",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_aligners(movData, total_steps):\n    upper_aligners = set()\n    lower_aligners = set()\n    for tooth, movement_list in movData.items():\n        current_step = 0\n        for movement in movement_list:\n            if movement[\"active\"]:\n                steps_active = int(movement[\"percent\"] / 100 * total_steps)\n                for step in range(current_step, current_step + steps_active):\n                    if tooth.startswith(('1', '2')):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "calculate_aligners_by_arcanum",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def calculate_aligners_by_arcanum(movDataByArcanum):\n    upper_aligners = 0\n    lower_aligners = 0\n    for step, movement in movDataByArcanum.items():\n        if movement[\"Upper\"]:\n            upper_aligners += 1\n        if movement[\"Lower\"]:\n            lower_aligners += 1\n    return upper_aligners, lower_aligners\ndef generateAFcheck(jsonData):",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateAFcheck",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateAFcheck(jsonData):\n  jsonAfCheck = {}\n  jsonAfCheck[\"aligners\"] = []\n  jsonAfCheck[\"attachments\"] = []\n  paris_tz = timezone(timedelta(hours=2))\n  # upper_aligners = 0\n  # lower_aligners = 0\n  alignersInd = 0\n  for stage in jsonData[\"stages\"]:\n    try:",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "parallel_process_files",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def parallel_process_files(\n    uncompressed_files, \n    uncom_files_dir, \n    splitted_files_dir, \n    optimized_files_dir,\n    file_pattern,         # ex: re.compile(...)\n    generate_obj, \n    callback_status_func, # ou None\n    a_3d_o,               # pour callback\n    main,                 # votre fonction de splitting",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "generateOptimizedData",
        "kind": 2,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "def generateOptimizedData(\n  uncom_files_dir,\n  splitted_files_dir,\n  optimized_files_dir,\n  export_dir, \n  ipr_data_filename,\n  landmark_data_filename,\n  output_json_filename, \n  bolton_analysis_file,\n  landmarkxls_data_filename,",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "BLENDER_PATH",
        "kind": 5,
        "importPath": "lib.optimize.objsplit",
        "description": "lib.optimize.objsplit",
        "peekOfCode": "BLENDER_PATH = os.getenv('BLENDER_PATH', 'blender')\n@contextmanager\ndef suppress_stdout():\n    with open(os.devnull, \"w\") as devnull:\n        old_stdout = sys.stdout\n        sys.stdout = devnull\n        try:\n            yield\n        finally:\n            sys.stdout = old_stdout",
        "detail": "lib.optimize.objsplit",
        "documentation": {}
    },
    {
        "label": "Migration",
        "kind": 6,
        "importPath": "member.migrations.0001_initial",
        "description": "member.migrations.0001_initial",
        "peekOfCode": "class Migration(migrations.Migration):\n    initial = True\n    dependencies = [\n    ]\n    operations = [\n        migrations.CreateModel(\n            name='Member',\n            fields=[\n                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n                ('image', s3direct.fields.S3DirectField(blank=True)),",
        "detail": "member.migrations.0001_initial",
        "documentation": {}
    },
    {
        "label": "MemberAdmin",
        "kind": 6,
        "importPath": "member.admin",
        "description": "member.admin",
        "peekOfCode": "class MemberAdmin(ImportExportModelAdmin):\n  fields = (\n    'id',\n    'image',\n    'image_tag',\n    'email',\n    'type',\n    'first_name',\n    'last_name',\n    'telnumber',",
        "detail": "member.admin",
        "documentation": {}
    },
    {
        "label": "MemberConfig",
        "kind": 6,
        "importPath": "member.apps",
        "description": "member.apps",
        "peekOfCode": "class MemberConfig(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = 'member'",
        "detail": "member.apps",
        "documentation": {}
    },
    {
        "label": "Member",
        "kind": 6,
        "importPath": "member.models",
        "description": "member.models",
        "peekOfCode": "class Member(models.Model):\n    ADMIN = 'ADMIN'\n    USER = 'USER'\n    MEMBER_TYPE = (\n        (ADMIN, ADMIN),\n        (USER, USER),\n    )\n    image = S3DirectField(dest='member_images', blank=True)\n    email = models.CharField(max_length=60, blank=False)\n    type = models.CharField(choices=MEMBER_TYPE, max_length=15, blank=False)",
        "detail": "member.models",
        "documentation": {}
    },
    {
        "label": "MemberSerializer",
        "kind": 6,
        "importPath": "member.serializers",
        "description": "member.serializers",
        "peekOfCode": "class MemberSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Member\n    fields = (\n      'id',\n      'image',\n      'email',\n      'type',\n      'first_name',\n      'last_name',",
        "detail": "member.serializers",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "member.urls",
        "description": "member.urls",
        "peekOfCode": "urlpatterns = [\n  path('all/', views.MemberList.as_view()),\n  path('create/', views.MemberCreate.as_view()),\n  path('<int:pk>/', views.MemberDetail.as_view()),\n]",
        "detail": "member.urls",
        "documentation": {}
    },
    {
        "label": "MemberList",
        "kind": 6,
        "importPath": "member.views",
        "description": "member.views",
        "peekOfCode": "class MemberList(APIView):\n  permission_classes = []\n  @swagger_auto_schema(\n    manual_parameters=FilterPagination.generate_pagination_params(),\n    responses={200: MemberSerializer(many=True)}\n  )\n  def get(self, request, format=None):\n    resultset = FilterPagination.get_paniation_data(\n      request,\n      Member,",
        "detail": "member.views",
        "documentation": {}
    },
    {
        "label": "MemberDetail",
        "kind": 6,
        "importPath": "member.views",
        "description": "member.views",
        "peekOfCode": "class MemberDetail(APIView):\n  def get_object(self, pk):\n    try:\n      return Member.objects.get(pk=pk)\n    except Member.DoesNotExist:\n      raise Http404\n  @swagger_auto_schema(\n    responses={200: MemberSerializer(many=False)}\n  )\n  def get(self, request, pk, format=None):",
        "detail": "member.views",
        "documentation": {}
    },
    {
        "label": "MemberCreate",
        "kind": 6,
        "importPath": "member.views",
        "description": "member.views",
        "peekOfCode": "class MemberCreate(APIView):\n  @swagger_auto_schema(\n      request_body=MemberSerializer(many=False),\n      responses={200: MemberSerializer(many=False)}\n  )\n  def post(self, request, format=None):\n    serializer = MemberSerializer(data=request.data, many=False)\n    if serializer.is_valid():\n      # Create new member with serializer\n      new_item = Member.objects.create(**serializer.validated_data)",
        "detail": "member.views",
        "documentation": {}
    },
    {
        "label": "InvalidUserModel",
        "kind": 6,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "class InvalidUserModel(Exception):\n    \"\"\"The member model you provided is invalid\"\"\"\n    pass\nclass EmailTemplateNotFound(Exception):\n    \"\"\"No email template found\"\"\"\n    pass\nclass NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass\ndef my_functional_view(request, member):",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "EmailTemplateNotFound",
        "kind": 6,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "class EmailTemplateNotFound(Exception):\n    \"\"\"No email template found\"\"\"\n    pass\nclass NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass\ndef my_functional_view(request, member):\n    # send_email(member)\n    return render('/email/verify/')\ndef _get_validated_field(field, default_type=None):",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "NotAllFieldCompiled",
        "kind": 6,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "class NotAllFieldCompiled(Exception):\n    \"\"\"Compile all the fields in the settings\"\"\"\n    pass\ndef my_functional_view(request, member):\n    # send_email(member)\n    return render('/email/verify/')\ndef _get_validated_field(field, default_type=None):\n    if default_type is None:\n        default_type = str\n    try:",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "my_functional_view",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def my_functional_view(request, member):\n    # send_email(member)\n    return render('/email/verify/')\ndef _get_validated_field(field, default_type=None):\n    if default_type is None:\n        default_type = str\n    try:\n        d = getattr(settings, field)\n        if d == \"\" or d is None or not isinstance(d, default_type):\n            raise AttributeError",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_member_password_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_member_password_email_context(member):\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    subject = _get_validated_field('EMAIL_PASSWORD_GENERATE_MAIL_SUBJECT')\n    domain += '/' if not domain.endswith('/') else ''\n    site_domain = urlparse(domain).netloc\n    receiver_name = member.full_name()\n    context = {\n        'member': member,\n        'subject': subject,",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_member_password",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_member_password(member, thread=True):\n    with send_email_member_password_lock:\n        mail_plain = _get_validated_field('EMAIL_PASSWORD_GENERATE_MAIL_PLAIN')\n        mail_html = \"../templates/\" + _get_validated_field('EMAIL_PASSWORD_GENERATE_MAIL_HTML')\n        context = get_member_password_email_context(member)\n        args = (member, context['sender'], context['subject'], mail_plain, mail_html, context, \"ACCOUNT CREATED\")\n        if thread:\n            t = Thread(target=send_email_thread, args=args)\n            t.start()\n        else:",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_invoice_pdf_file",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_invoice_pdf_file(activity):\n    try:\n        if (activity.activity_type == Activity.ACTIVITY_LAB_SENT_INVOICE) or \\\n           (activity.activity_type == Activity.ACTIVITY_LAB_SENT_INVOICE_FINITION1) or \\\n           (activity.activity_type == Activity.ACTIVITY_LAB_SENT_INVOICE_FINITION2) or \\\n           (activity.activity_type == Activity.ACTIVITY_LAB_SENT_RETAINER_INVOICE):\n            if activity.meta_data:\n                json_meta = json.loads(activity.meta_data)\n                if ('data' in json_meta) and (json_meta['data']):\n                    data = json_meta['data']",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_finition_index",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_finition_index(activity):\n    try:\n        if activity.activity_type == Activity.ACTIVITY_LAB_SENT_INVOICE_FINITION2:\n            if activity.meta_data:\n                json_meta = json.loads(activity.meta_data)\n                if ('data' in json_meta) and (json_meta['data']):\n                    data = json_meta['data']\n                    if 'id' in data:\n                        invoice_id = data['id']\n                        invoice = Invoice.objects.filter(id=invoice_id).first()",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_shipment_carrier_link",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_shipment_carrier_link(activity):\n    if activity.activity_type != Activity.ACTIVITY_LAB_SHIPPING_ALIGNERS and \\\n        activity.activity_type != Activity.ACTIVITY_LAB_SHIPPING_RETAINER:\n        return None\n    try:\n        if activity.meta_data:\n            json_meta = json.loads(activity.meta_data)\n            if ('data' in json_meta) and (json_meta['data']):\n                data = json_meta['data']\n                if 'id' in data:",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_activity_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_activity_email_context(activity):\n    patient = activity.patient\n    source = activity.source\n    destination = activity.destination\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    patient_name = patient.full_name()\n    patient_image = \"https://aligneursfrancais.s3.eu-west-3.amazonaws.com/logos/email/utilisateur.png\"\n    receiver_name = destination.full_name()\n    domain += '/' if not domain.endswith('/') else ''",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_activity_email_context_direct",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_activity_email_context_direct(activity, third_reject, isContainkit_balance,is_team_email=False):\n    patient = activity.patient\n    member = patient.dentist\n    source = activity.source\n    destination = activity.destination\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    patient_name = patient.full_name()\n    patient_image = \"https://aligneursfrancais.s3.eu-west-3.amazonaws.com/logos/email/utilisateur.png\"\n    receiver_name = 'Hi there'",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_email_activity_template",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_email_activity_template(activity_type):\n    for act_temp in EMAILING_ACTIVITY_TEMPLATES:\n        if activity_type in act_temp['activity_types']:\n            return {\n                'template': act_temp['template'],\n                'plan': act_temp['plan']\n            }\n    return None\ndef send_email_thread(member, sender, subject, mail_plain, mail_html, context, email_type):   \n    text = render_to_string(mail_plain, context)",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_thread",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_thread(member, sender, subject, mail_plain, mail_html, context, email_type):   \n    text = render_to_string(mail_plain, context)\n    html = render_to_string(mail_html, context)\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    try:\n        Smtp_SendMail(subject, text, html, sender, member.email, password)\n    except Exception as ex:\n        logger.error(f'Failed to send email: id = {member.id}: {str(ex)} ({type(ex)}) on {ex.__traceback__.tb_lineno} line')\n        return False\n    logger.info(f'Sent an email successfully: member id = {member.id}')",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_thread_direct",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_thread_direct(member, sender, subject, mail_plain, mail_html, context, isContainkit_balance,activity, is_team_email=False):\n    text = render_to_string(mail_plain, context)\n    html = render_to_string(mail_html, context)\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    email_type = activity.activity_type\n    patient = activity.patient\n    # if member.referent == 'yasmine_ghedira':\n    #     email = 'yasmineg@aligneursfrancais.com'\n    # else:\n    #     email = 'selim@aligneursfrancais.com'",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_reminder_email_STL",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_reminder_email_STL(patient, thread=True):\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    context = {\n        'patient_name': patient.full_name().capitalize(),\n    }\n    subject = f\"Empreintes manquantes - {patient.full_name().capitalize()}\"\n    mail_html = \"../templates/\" + _get_validated_field(\"EMAIL_REMINDER_STL_HTML\")\n    text = f\"Sauf erreur de notre part, nous n’avons toujours pas reçu les STLs pour le patient : {patient.full_name().capitalize()}\"\n    args = (patient.dentist, sender, subject, text, mail_html, context)",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_reminder_email_STL_thread",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_reminder_email_STL_thread(member, sender, subject, text, mail_html, context):\n    html = render_to_string(mail_html, context)\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    try:\n        Smtp_SendMail(subject, text, html, sender, member.email, password)\n    except Exception as ex:\n        logger.error(f'Failed to send email: id = {member.id}: {str(ex)} ({type(ex)}) on {ex.__traceback__.tb_lineno} line')\n        return False\n    logger.info(f'Sent an email successfully: member id = {member.id}')\n    if is_html(text):",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_activity",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_activity(activity, thread=True):\n    if not activity.activity_type in EMAILING_ACTIVITY_TYPES:\n        # Skip emailing\n        logger.warning(f'send_email_activity: skip emailing because the type is not in emailing list: {activity.activity_type}')\n        return\n    if activity.email_sent:\n        logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n        return\n    destination = activity.destination\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_activity_direct",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_activity_direct(member, activity, third_reject, thread=True, isContainkit_balance=False, is_team_email=False):\n    if not activity.activity_type in EMAILING_ACTIVITY_TYPES:\n        # Skip emailing\n        logger.warning(f'send_email_activity: skip emailing because the type is not in emailing list: {activity.activity_type}')\n        return\n\t# if activity.email_sent:\n    #     logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n    #     return\n    destination = activity.destination\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_customer_created",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_customer_created(client):\n    # destination = \"nicky.softimad@gmail.com\"\n    destination = \"jane.b@aligneursfrancais.com\"\n    # destination = \"eg@finmanagement.co\"\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    context = {\n        'client': client,\n    }\n    subject = 'Nouveau client ajouté'",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_approved_afsetup_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_approved_afsetup_email_context(activity):\n    patient = activity.patient\n    destination = patient.dentist\n    source = get_lab()\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    patient_name = patient.full_name()\n    patient_image = \"https://aligneursfrancais.s3.eu-west-3.amazonaws.com/logos/email/utilisateur.png\"\n    receiver_name = destination.last_name\n    domain += '/' if not domain.endswith('/') else ''",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_approved_afsetup_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_approved_afsetup_email(activity, thread=True):\n    with send_approved_afsetup_email_lock:\n        if activity.email_sent:\n            logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n            return\n        destination = activity.source\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')    \n        context = get_approved_afsetup_email_context(activity)\n        subject = context['subject']\n        email_template = {",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_invoice_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_invoice_email_context(activity):\n    patient = activity.patient\n    destination = patient.dentist\n    source = get_lab()\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    patient_name = patient.full_name()\n    patient_image = \"https://aligneursfrancais.s3.eu-west-3.amazonaws.com/logos/email/utilisateur.png\"\n    receiver_name = destination.last_name\n    domain += '/' if not domain.endswith('/') else ''",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_invoice_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_invoice_email(activity, thread=True):\n    with send_invoice_email_lock:\n        if activity.email_sent:\n            logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n            return\n        destination = activity.destination\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')    \n        context = get_invoice_email_context(activity)\n        subject = context['subject']\n        email_template = {",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_invoice_30days_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_invoice_30days_email_context(invoice):\n    af_setup = invoice.af_setup\n    treatment = af_setup.treatment\n    dentist = treatment.dentist\n    patient = treatment.patient\n    destination = dentist\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    patient_name = patient.full_name()\n    patient_image = \"https://aligneursfrancais.s3.eu-west-3.amazonaws.com/logos/email/utilisateur.png\"",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_invoice_30days_email_template",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_invoice_30days_email_template(invoice):\n    return {\n        'template': _get_validated_field('EMAIL_INVOICE_30DAYS_MAIL_HTML'),\n        'plan': _get_validated_field('EMAIL_INVOICE_30DAYS_MAIL_PLAIN')\n    }\ndef need_to_send_email(invoice):\n    INTERVAL_EMAILING_DAYS = 30\n    created_at = invoice.created_at.replace(tzinfo=None)\n    if created_at < datetime(year=2022, month=3, day=1):\n        return False",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "need_to_send_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def need_to_send_email(invoice):\n    INTERVAL_EMAILING_DAYS = 30\n    created_at = invoice.created_at.replace(tzinfo=None)\n    if created_at < datetime(year=2022, month=3, day=1):\n        return False\n    iss = list(map(itemgetter(0), Invoice.INVOICE_STATUS_CHOICE))\n    if iss.index(invoice.status) >= iss.index(Invoice.PAID):\n        return False\n    if invoice.amount == 0:\n        return False",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_invoice_30days_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_invoice_30days_email(invoice, thread=True):\n    with send_invoice_30days_email_lock:\n        logger.info(f'Invoice ID: #{invoice.id}')\n        if not need_to_send_email(invoice):\n            logger.info(f\"Skip to send invoice email for 30days because it's match to condition.\")\n            return False\n        af_setup = invoice.af_setup\n        treatment = af_setup.treatment\n        dentist = treatment.dentist\n        destination = dentist",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_message",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_message(message, thread=True):\n    with send_email_message_lock:\n        sender = message.sender\n        receiver = message.receiver\n        patient = message.conversation.patient\n        from_email = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n        description = ''\n        subject = sender.full_name() + ' sent '\n        if message.type == Message.MESSAGE_TEXT:",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_contact_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_contact_context(member, message):\n    dentist_name = member.full_name()\n    dentist_email = member.email\n    context = {\n        'member': member,\n        'dentist_name': dentist_name, \n        'dentist_email': dentist_email,\n        'message': message,\n    }\n    return context",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_contact",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_contact(member, receiver, subject, message, thread=True):\n    with send_email_contact_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        context = get_contact_context(member, message)\n        subject = subject\n        email_template = {\n            'template': _get_validated_field('EMAIL_CONTACT_MAIL_HTML'),\n            'plan': _get_validated_field('EMAIL_CONTACT_MAIL_PLAIN')\n        }\n        mail_plain = email_template['plan']",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_contact_email_thread",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_contact_email_thread(member, receiver, sender, subject, mail_plain, mail_html, context):   \n    text = render_to_string(mail_plain, context)\n    html = render_to_string(mail_html, context)\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    try:\n        Smtp_SendMail(subject, text, html, sender, receiver, password)\n    except Exception as ex:\n        logger.error(f'Failed to send a contact email: id = {member.id}: {str(ex)} ({type(ex)}) on {ex.__traceback__.tb_lineno} line')\n        return False\n    logger.info(f'Sent a contact email successfully from member: member id = {member.id}')",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_csv",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_csv(email_address, file_url, title='', thread=True):\n    with send_email_csv_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = [{\n            'title': title,\n            'file': file_url\n        }]\n        context = {\n            'subject': f'Download the {title} csv file.',\n            'message': f'We attached the {title} csv file. You can download it by clicking the linked file.',",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_refered_generate_promo_code",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_refered_generate_promo_code(refered_dentist, referer_dentist, promo_code, title='', thread=True):\n    with send_email_refered_generate_promo_code_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Profitez-en ! Vous avez reçu une réduction de -50%\"\n        message = f\"\"\"\n            Bonjour Dr {refered_dentist.last_name}\n            <br>\n            <br>\n            Le DR {referer_dentist.last_name} est désormais votre parrain Aligneurs Français. ",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_referer_first_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_referer_first_email(refered_dentist, referer_dentist, title='', thread=True):\n    with send_email_referer_first_email_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Bonjour Dr {referer_dentist.last_name}, merci d'avoir parrainé l'un de vos confrères !\"\n        message = f\"\"\"\n            Bonjour Dr {referer_dentist.last_name}\n            <br>\n            <br>\n            Le parrainage du DR {refered_dentist.last_name} a bien été noté par nos équipes. ",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_referer_second_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_email_referer_second_email(refered_dentist, referer_dentist, promo_code, title='', thread=True):\n    with send_email_referer_second_email_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Bonjour Dr {referer_dentist.last_name}, merci d'avoir parrainé l'un de vos confrères !\"\n        message = f\"\"\"\n            Bonjour Dr {referer_dentist.last_name}\n            <br>\n            <br>\n            Le DR {refered_dentist.last_name} que vous avez parrainé il y a peu a commencé son premier traitement Aligneurs Français. ",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "raw_send_email_thread",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def raw_send_email_thread(email_address, sender, subject, mail_plain, mail_html, context, email_type):   \n    text = render_to_string(mail_plain, context)\n    html = render_to_string(mail_html, context)\n    password = _get_validated_field('EMAIL_HOST_PASSWORD')\n    try:\n        Smtp_SendMail(subject, text, html, sender, email_address, password)\n    except Exception as ex:\n        logger.error(f'Failed to send email: address = {email_address}: {str(ex)} ({type(ex)}) on {ex.__traceback__.tb_lineno} line')\n        return False\n    logger.info(f'Sent an email successfully: address = {email_address}')",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "dentist_promotion_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def dentist_promotion_email(dentist_profile, discount_percentage, remaining_treatments):\n    template = get_template(\"dentist_promotion_mail_body.html\")\n    params = {\n        \"dentist_name\": dentist_profile.dentist.full_name(),\n        \"dentist_status\": dentist_profile.dentist_status,\n        \"discount\": discount_percentage,\n        \"remaining_treatments\": remaining_treatments\n    }\n    message = template.render(params)\n    mail = EmailMessage(",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "dentist_demotion_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def dentist_demotion_email(dentist_profile):\n    dentist = dentist_profile.dentist\n    template = get_template(\"dentist_demotion_mail_body.html\")\n    params = {\n        \"dentist_name\": dentist.full_name(),\n    }\n    message = template.render(params)\n    mail = EmailMessage(\n        subject=\"Bonjour Dr \" + dentist.last_name + \", votre statut Aligneurs Français a changé..\",\n        body=message,",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "dentist_remaining_treatment_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def dentist_remaining_treatment_email(dentist_profile):\n    dentist = dentist_profile.dentist\n    template = get_template(\"dentist_remaining_treatments_mail_body.html\")\n    params = {\n        \"dentist_name\": dentist.full_name(),\n    }\n    message = template.render(params)\n    mail = EmailMessage(\n        subject=\"BONJOUR DR \" + dentist.last_name + \", IL NE VOUS RESTE PLUS QU'UN TRAITEMENT AVANT LE PROCHAIN PALIER DE FIDÉLITÉ !\",\n        body=message,",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "get_af_setup_reminder_email_context",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def get_af_setup_reminder_email_context(af_setup):\n    treatment = af_setup.treatment\n    patient = treatment.patient\n    dentist = patient.dentist\n    patient_name = patient.full_name()\n    sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n    domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n    domain += '/' if not domain.endswith('/') else ''\n    user_type = 'dentist'\n    patient_link = f'{domain}{user_type}/patients/{patient.id}'",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_af_setup_reminder_email",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_af_setup_reminder_email(af_setup, template_name):\n    context = get_af_setup_reminder_email_context(af_setup)\n    template = get_template(template_name)\n    message = template.render(context)\n    mail = EmailMessage(\n        subject=context[\"subject\"],\n        body=message,\n        from_email=context[\"sender\"],\n        to=[context[\"dentist\"].email],\n        headers={'Reply-To': context[\"dentist\"].email}",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_af_setup_reminders",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def send_af_setup_reminders():\n    # Helper function for querying AFSetup records\n    def get_af_setup_records(days_ago):\n        target_date = datetime.now() - timedelta(days=days_ago)\n        queries = Q(state=AFSetup.AF_SETUP_GENERATED) & Q(af_setup_date__date=target_date.date())\n        return AFSetup.objects.filter(queries).all()\n    # Send 1 week reminder emails\n    # for raf in get_af_setup_records(7):  # 1 week is 7 days\n    #     send_af_setup_reminder_email(raf, \"af_setup_remainder_one_week.html\")\n    #     time.sleep(5)",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "is_html",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def is_html(content):\n    return bool(re.search(r'<[^>]+>', content))\ndef extract_text_from_html(html_content):\n    # Enlever les balises <style> et leur contenu\n    html_content = re.sub(r'<style.*?>.*?</style>', '', html_content, flags=re.DOTALL)\n    # Enlever les balises <script> et leur contenu\n    html_content = re.sub(r'<script.*?>.*?</script>', '', html_content, flags=re.DOTALL)\n    # Extraire le titre\n    title_match = re.search(r'<title>(.*?)</title>', html_content)\n    title = title_match.group(1) if title_match else ''",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "extract_text_from_html",
        "kind": 2,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "def extract_text_from_html(html_content):\n    # Enlever les balises <style> et leur contenu\n    html_content = re.sub(r'<style.*?>.*?</style>', '', html_content, flags=re.DOTALL)\n    # Enlever les balises <script> et leur contenu\n    html_content = re.sub(r'<script.*?>.*?</script>', '', html_content, flags=re.DOTALL)\n    # Extraire le titre\n    title_match = re.search(r'<title>(.*?)</title>', html_content)\n    title = title_match.group(1) if title_match else ''\n    # Supprimer la balise <title> du contenu HTML\n    html_content = re.sub(r'<title>.*?</title>', '', html_content)",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "EMAILING_ACTIVITY_TYPES",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "EMAILING_ACTIVITY_TYPES = [\n#   Activity.ACTIVITY_DENTIST_ADDED_PATIENT,\n  Activity.ACTIVITY_DENTIST_STARTED_TREATMENT,\n  Activity.ACTIVITY_DENTIST_SHPPED_FOOTPRINT,  \n  Activity.ACTIVITY_DENTIST_SHIPPED_IMPRINT,\n  Activity.ACTIVITY_DENTIST_REQUIRED_AF_SETUP,\n  Activity.ACTIVITY_DENTIST_APPROVED_AF_SETUP,  \n  Activity.ACTIVITY_DENTIST_REJECTED_AF_SETUP,\n  Activity.ACTIVITY_DENTIST_RECEIVED_ALIGNERS,\n  Activity.ACTIVITY_DENTIST_GENERATE_RETAINER,",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "EMAILING_CREATED_CUSTOMER",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "EMAILING_CREATED_CUSTOMER = [\n    {\n        'template': 'EMAIL_CREATED_CUSTOMER',\n        'plan': 'EMAIL_CREATED_CUSTOMER_PLAIN',\n    }\n]\nEMAILING_ACTIVITY_TEMPLATES = [\n    {\n        'template': 'EMAIL_ACTIVITY_MAIL_HTML',\n        'plan': 'EMAIL_ACTIVITY_MAIL_PLAIN',",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "EMAILING_ACTIVITY_TEMPLATES",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "EMAILING_ACTIVITY_TEMPLATES = [\n    {\n        'template': 'EMAIL_ACTIVITY_MAIL_HTML',\n        'plan': 'EMAIL_ACTIVITY_MAIL_PLAIN',\n        'activity_types': [\n            Activity.ACTIVITY_DENTIST_SHPPED_FOOTPRINT,  \n            Activity.ACTIVITY_DENTIST_SHIPPED_IMPRINT,\n            Activity.ACTIVITY_DENTIST_REQUIRED_AF_SETUP,\n            Activity.ACTIVITY_DENTIST_RECEIVED_ALIGNERS,\n            Activity.ACTIVITY_DENTIST_GENERATE_RETAINER,",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_member_password_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_member_password_lock = Lock()\ndef send_email_member_password(member, thread=True):\n    with send_email_member_password_lock:\n        mail_plain = _get_validated_field('EMAIL_PASSWORD_GENERATE_MAIL_PLAIN')\n        mail_html = \"../templates/\" + _get_validated_field('EMAIL_PASSWORD_GENERATE_MAIL_HTML')\n        context = get_member_password_email_context(member)\n        args = (member, context['sender'], context['subject'], mail_plain, mail_html, context, \"ACCOUNT CREATED\")\n        if thread:\n            t = Thread(target=send_email_thread, args=args)\n            t.start()",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_approved_afsetup_email_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_approved_afsetup_email_lock = Lock()\ndef send_approved_afsetup_email(activity, thread=True):\n    with send_approved_afsetup_email_lock:\n        if activity.email_sent:\n            logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n            return\n        destination = activity.source\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')    \n        context = get_approved_afsetup_email_context(activity)\n        subject = context['subject']",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_invoice_email_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_invoice_email_lock = Lock()\ndef send_invoice_email(activity, thread=True):\n    with send_invoice_email_lock:\n        if activity.email_sent:\n            logger.info(f'send_email_activity: email already sent for activity {activity.id}')\n            return\n        destination = activity.destination\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')    \n        context = get_invoice_email_context(activity)\n        subject = context['subject']",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_invoice_30days_email_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_invoice_30days_email_lock = Lock()\ndef send_invoice_30days_email(invoice, thread=True):\n    with send_invoice_30days_email_lock:\n        logger.info(f'Invoice ID: #{invoice.id}')\n        if not need_to_send_email(invoice):\n            logger.info(f\"Skip to send invoice email for 30days because it's match to condition.\")\n            return False\n        af_setup = invoice.af_setup\n        treatment = af_setup.treatment\n        dentist = treatment.dentist",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_message_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_message_lock = Lock()\ndef send_email_message(message, thread=True):\n    with send_email_message_lock:\n        sender = message.sender\n        receiver = message.receiver\n        patient = message.conversation.patient\n        from_email = _get_validated_field('EMAIL_FROM_ADDRESS')\n        domain = _get_validated_field('EMAIL_PAGE_DOMAIN')\n        description = ''\n        subject = sender.full_name() + ' sent '",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_contact_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_contact_lock = Lock()\ndef send_email_contact(member, receiver, subject, message, thread=True):\n    with send_email_contact_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        context = get_contact_context(member, message)\n        subject = subject\n        email_template = {\n            'template': _get_validated_field('EMAIL_CONTACT_MAIL_HTML'),\n            'plan': _get_validated_field('EMAIL_CONTACT_MAIL_PLAIN')\n        }",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_csv_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_csv_lock = Lock()\ndef send_email_csv(email_address, file_url, title='', thread=True):\n    with send_email_csv_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = [{\n            'title': title,\n            'file': file_url\n        }]\n        context = {\n            'subject': f'Download the {title} csv file.',",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_refered_generate_promo_code_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_refered_generate_promo_code_lock = Lock()\ndef send_email_refered_generate_promo_code(refered_dentist, referer_dentist, promo_code, title='', thread=True):\n    with send_email_refered_generate_promo_code_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Profitez-en ! Vous avez reçu une réduction de -50%\"\n        message = f\"\"\"\n            Bonjour Dr {refered_dentist.last_name}\n            <br>\n            <br>",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_referer_first_email_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_referer_first_email_lock = Lock()\ndef send_email_referer_first_email(refered_dentist, referer_dentist, title='', thread=True):\n    with send_email_referer_first_email_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Bonjour Dr {referer_dentist.last_name}, merci d'avoir parrainé l'un de vos confrères !\"\n        message = f\"\"\"\n            Bonjour Dr {referer_dentist.last_name}\n            <br>\n            <br>",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "send_email_referer_second_email_lock",
        "kind": 5,
        "importPath": "utils.email_utils",
        "description": "utils.email_utils",
        "peekOfCode": "send_email_referer_second_email_lock = Lock()\ndef send_email_referer_second_email(refered_dentist, referer_dentist, promo_code, title='', thread=True):\n    with send_email_referer_second_email_lock:\n        sender = _get_validated_field('EMAIL_FROM_ADDRESS')\n        attached_files = []\n        subject = f\"Bonjour Dr {referer_dentist.last_name}, merci d'avoir parrainé l'un de vos confrères !\"\n        message = f\"\"\"\n            Bonjour Dr {referer_dentist.last_name}\n            <br>\n            <br>",
        "detail": "utils.email_utils",
        "documentation": {}
    },
    {
        "label": "custom_exception_handler",
        "kind": 2,
        "importPath": "utils.error_utils",
        "description": "utils.error_utils",
        "peekOfCode": "def custom_exception_handler(exc, context):\n  response = exception_handler(exc, context)\n  capture_message(exc, level=\"error\")\n  # discord_track_errors(exc, context)\n  logger.error(str(context))\n  return response",
        "detail": "utils.error_utils",
        "documentation": {}
    },
    {
        "label": "get_member_model",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def get_member_model():\n  return Member\ndef get_lab():\n  return Member.objects.filter(type=Member.LAB).order_by('id').first()\ndef get_admin():\n  return Member.objects.filter(type=Member.ADMIN).order_by('id').first()\ndef get_deactive_loyalty_dentists():\n  return Member.objects.filter(type=Member.DENTIST, deactive_loyalty=True).order_by('id')\ndef get_member(member_id):\n  return Member.objects.filter(id=member_id).first()",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_lab",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def get_lab():\n  return Member.objects.filter(type=Member.LAB).order_by('id').first()\ndef get_admin():\n  return Member.objects.filter(type=Member.ADMIN).order_by('id').first()\ndef get_deactive_loyalty_dentists():\n  return Member.objects.filter(type=Member.DENTIST, deactive_loyalty=True).order_by('id')\ndef get_member(member_id):\n  return Member.objects.filter(id=member_id).first()\ndef generate_password():\n  symbols = string.punctuation",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_admin",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def get_admin():\n  return Member.objects.filter(type=Member.ADMIN).order_by('id').first()\ndef get_deactive_loyalty_dentists():\n  return Member.objects.filter(type=Member.DENTIST, deactive_loyalty=True).order_by('id')\ndef get_member(member_id):\n  return Member.objects.filter(id=member_id).first()\ndef generate_password():\n  symbols = string.punctuation\n  password = \"\"\n  for _ in range(9):",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_deactive_loyalty_dentists",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def get_deactive_loyalty_dentists():\n  return Member.objects.filter(type=Member.DENTIST, deactive_loyalty=True).order_by('id')\ndef get_member(member_id):\n  return Member.objects.filter(id=member_id).first()\ndef generate_password():\n  symbols = string.punctuation\n  password = \"\"\n  for _ in range(9):\n    password += secrets.choice(string.ascii_lowercase)\n  password += secrets.choice(string.ascii_uppercase)",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "get_member",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def get_member(member_id):\n  return Member.objects.filter(id=member_id).first()\ndef generate_password():\n  symbols = string.punctuation\n  password = \"\"\n  for _ in range(9):\n    password += secrets.choice(string.ascii_lowercase)\n  password += secrets.choice(string.ascii_uppercase)\n  password += secrets.choice(string.digits)\n  password += secrets.choice(symbols)",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "generate_password",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def generate_password():\n  symbols = string.punctuation\n  password = \"\"\n  for _ in range(9):\n    password += secrets.choice(string.ascii_lowercase)\n  password += secrets.choice(string.ascii_uppercase)\n  password += secrets.choice(string.digits)\n  password += secrets.choice(symbols)\n  return password\ndef generate_api_key(member):",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "generate_api_key",
        "kind": 2,
        "importPath": "utils.member_utils",
        "description": "utils.member_utils",
        "peekOfCode": "def generate_api_key(member):\n  # Generate a unique API key\n  unique_key = uuid.uuid4()\n  # Use the user's id to make the API key unique to them\n  unique_key = f\"{member.id}{unique_key}\"\n  # Hash the key for additional security\n  api_key = hashlib.sha256(unique_key.encode('utf-8')).hexdigest()\n  return api_key",
        "detail": "utils.member_utils",
        "documentation": {}
    },
    {
        "label": "FilterPagination",
        "kind": 6,
        "importPath": "utils.pagination_utils",
        "description": "utils.pagination_utils",
        "peekOfCode": "class FilterPagination:\n    \"\"\"\n    Filtrage + Pagination optimisé.\n    - On ne transforme pas le queryset final en list pour permettre .values() plus tard.\n    - On mesure le temps et la taille mémoire via une variable temporaire.\n    - On peut utiliser .only(), .select_related(), .prefetch_related() avant la conversion.\n    \"\"\"\n    @staticmethod\n    def filter_and_pagination(request, model_reference, queries=None,\n                              order_by_array=None, special_order_by=None):",
        "detail": "utils.pagination_utils",
        "documentation": {}
    },
    {
        "label": "get_queryset_from_request",
        "kind": 2,
        "importPath": "utils.pagination_utils",
        "description": "utils.pagination_utils",
        "peekOfCode": "def get_queryset_from_request(request, model_reference, queries=None):\n    \"\"\"\n    Filtre un queryset sans pagination, en utilisant les paramètres GET.\n    Conserve un QuerySet (pas de list) pour pouvoir appeler .values() ensuite.\n    \"\"\"\n    start_time = time.time()\n    model_fields = [field.name for field in model_reference._meta.get_fields()]\n    filter_params = request.GET\n    custom_filter = {}\n    # Construction du filtre",
        "detail": "utils.pagination_utils",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PER_PAGE",
        "kind": 5,
        "importPath": "utils.pagination_utils",
        "description": "utils.pagination_utils",
        "peekOfCode": "DEFAULT_PER_PAGE = 12\ndef get_queryset_from_request(request, model_reference, queries=None):\n    \"\"\"\n    Filtre un queryset sans pagination, en utilisant les paramètres GET.\n    Conserve un QuerySet (pas de list) pour pouvoir appeler .values() ensuite.\n    \"\"\"\n    start_time = time.time()\n    model_fields = [field.name for field in model_reference._meta.get_fields()]\n    filter_params = request.GET\n    custom_filter = {}",
        "detail": "utils.pagination_utils",
        "documentation": {}
    },
    {
        "label": "join_two_queries",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def join_two_queries(first_query, second_query):\n  res = first_query\n  if second_query:\n    if res:\n      res = res & second_query\n    else:\n      res = second_query\n  return res\ndef filter_patients_by_user(request):\n  user = request.user",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "filter_patients_by_user",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def filter_patients_by_user(request):\n  user = request.user\n  patients  = Patient.objects.all()\n  if user.type == Member.DENTIST:\n    patients = patients.filter(dentist=user)\n    logger.debug(f'filtered patient by user. {patients.count()}')\n  return patients\ndef get_query_by_dentist(request):\n  if PARAM_DENTIST in request.GET:\n    dentist_id = request.GET[PARAM_DENTIST]",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_dentist",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_dentist(request):\n  if PARAM_DENTIST in request.GET:\n    dentist_id = request.GET[PARAM_DENTIST]\n    query = Q(dentist_id=dentist_id)\n    return query\n  return None\ndef get_query_by_dentist_sql(request):\n    if PARAM_DENTIST in request.GET:\n        dentist_id = request.GET[PARAM_DENTIST]\n        query = \"p.dentist_id = %s\"",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_dentist_sql",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_dentist_sql(request):\n    if PARAM_DENTIST in request.GET:\n        dentist_id = request.GET[PARAM_DENTIST]\n        query = \"p.dentist_id = %s\"\n        params = [dentist_id]\n        return {'sql': query, 'params': params}\n    return None\ndef get_query_by_user(request):\n  query = None\n  user = request.user",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_user",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_user(request):\n  query = None\n  user = request.user\n  if hasattr(user, 'type') and (user.type == Member.DENTIST):\n    query = Q(dentist=user)\n  return query\ndef get_query_by_user_sql(request):\n    user = request.user\n    if hasattr(user, 'type') and (user.type == Member.DENTIST):\n        query = \"p.dentist_id = %s\"",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_user_sql",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_user_sql(request):\n    user = request.user\n    if hasattr(user, 'type') and (user.type == Member.DENTIST):\n        query = \"p.dentist_id = %s\"\n        params = [user.id]\n        return {'sql': query, 'params': params}\n    return None\ndef get_query_by_clinic(request):\n  if PARAM_CLINIC in request.GET:\n    clinic_id = request.GET[PARAM_CLINIC]",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_clinic",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_clinic(request):\n  if PARAM_CLINIC in request.GET:\n    clinic_id = request.GET[PARAM_CLINIC]\n    # Get the related DentistProfile IDs associated with the clinic\n    dentist_profile_ids = DentistClinic.objects.filter(clinic_id=clinic_id).values_list('dentist_profile_id', flat=True)\n    # Get the associated dentist (Member) IDs\n    dentist_ids = set(DentistProfile.objects.filter(id__in=dentist_profile_ids).values_list('dentist_id', flat=True))\n    logger.debug(f'dentist_ids: {dentist_ids}')\n    # clinic = Clinic.objects.get(pk=clinic_id)\n    # cdps = clinic.clinic_dentist_profiles.all()",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_clinic_sql",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_clinic_sql(request):\n    if PARAM_CLINIC in request.GET:\n        clinic_id = request.GET[PARAM_CLINIC]\n        # Get the related DentistProfile IDs associated with the clinic\n        dentist_profile_ids = DentistClinic.objects.filter(clinic_id=clinic_id).values_list('dentist_profile_id', flat=True)\n        # Get the associated dentist (Member) IDs\n        dentist_ids = set(DentistProfile.objects.filter(id__in=dentist_profile_ids).values_list('dentist_id', flat=True))\n        if dentist_ids:\n            placeholders = ','.join(['%s'] * len(dentist_ids))\n            query = f\"p.dentist_id IN ({placeholders})\"",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_dp_query_by_dentist_name",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_dp_query_by_dentist_name(search_key):\n  query = Q(dentist__type=Member.DENTIST) & (\n    Q(dentist__first_name__icontains=search_key) | \\\n    Q(dentist__last_name__icontains=search_key)\n  )\n  return query\ndef get_query_by_user(request):\n  query = None\n  user = request.user\n  if hasattr(user, 'type') and (user.type == Member.DENTIST):",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_user",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_user(request):\n  query = None\n  user = request.user\n  if hasattr(user, 'type') and (user.type == Member.DENTIST):\n    query = Q(dentist=user)\n  return query\ndef get_query_by_archived(request):\n  query = None\n  user = request.user\n  if user is not None:  ",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_archived",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_archived(request):\n  query = None\n  user = request.user\n  if user is not None:  \n    p_ids = list(ArchivedPatient.objects.filter(member=user.id).values_list('patient_id', flat=True))\n    query = Q(id__in=p_ids)\n  return query\ndef get_query_by_type_member(request):\n  type_member = request.GET.get('type')\n  if type_member:",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_type_member",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_type_member(request):\n  type_member = request.GET.get('type')\n  if type_member:\n    query = query.filter(dentist__type=type_member)  # Filtrer les dentistes par type de membre\n  return query\nFILTER_TYPE_VALUES = [\n  'ALL',\n  'FINITION', \n  'IMPRINT',\n]",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_filter_type",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_filter_type(request):\n  from pprint import pprint\n  if PARAM_FILTER_TYPE in request.GET:\n    filter_type = request.GET[PARAM_FILTER_TYPE]\n    str_sql = None\n    if filter_type == 'FINITION':\n      str_sql = finition_patients_sql\n    elif filter_type == 'IMPRINT':\n      str_sql = imprint_patients_sql\n    if str_sql:",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_filter_team",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_filter_team(request):\n  if PARAM_FILTER_TEAM in request.GET:\n    filter_team = request.GET[PARAM_FILTER_TEAM]\n    query = Q(af_setup_team_id=filter_team) \n    return query\n  return None\ndef get_query_by_filter_type_sql(request):\n    if PARAM_FILTER_TYPE in request.GET:\n        filter_type = request.GET[PARAM_FILTER_TYPE]\n        str_sql = None",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_filter_type_sql",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_filter_type_sql(request):\n    if PARAM_FILTER_TYPE in request.GET:\n        filter_type = request.GET[PARAM_FILTER_TYPE]\n        str_sql = None\n        if filter_type == 'FINITION':\n            str_sql = finition_patients_sql\n        elif filter_type == 'IMPRINT':\n            str_sql = imprint_patients_sql\n        if str_sql:\n            items = execute_raw_sql(str_sql)",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_retainer_filter_type",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_retainer_filter_type(request):\n  if PARAM_FILTER_TYPE in request.GET:\n    filter_type = request.GET[PARAM_FILTER_TYPE]\n    str_sql = None\n    if filter_type == 'IMPRINT':\n      str_sql = retainer_imprint_patients_sql\n    if str_sql:\n      items = execute_raw_sql(str_sql)\n      patient_ids = list(map(lambda x : x['id'], items))\n      queries = Q(id__in=patient_ids)",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "get_query_by_clinicManager_OR_dentistManager",
        "kind": 2,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "def get_query_by_clinicManager_OR_dentistManager(request):\n  query = None\n  user = request.user\n  if hasattr(user, 'type') and (user.type == Member.MANAGER):\n    # Sous-requête pour les cliniciens (clinic_id)\n    # clinic_ids = Clinic.objects.filter(manager=user).values('id')\n    # Sous-requête pour les dentistes (dentist_id)\n    dentist_ids = DentistProfile.objects.filter(manager=user).values('dentist_id')\n    # Combine les deux sous-requêtes avec OR\n    # query = Q(clinic__id__in=Subquery(clinic_ids)) | Q(dentist__in=Subquery(dentist_ids))",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "PARAM_DENTIST",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "PARAM_DENTIST = 'dentist'\nPARAM_CLINIC = 'clinic'\nPARAM_FILTER_TYPE = 'filter_type'\nPARAM_FILTER_TEAM = 'filter_team'\ndef join_two_queries(first_query, second_query):\n  res = first_query\n  if second_query:\n    if res:\n      res = res & second_query\n    else:",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "PARAM_CLINIC",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "PARAM_CLINIC = 'clinic'\nPARAM_FILTER_TYPE = 'filter_type'\nPARAM_FILTER_TEAM = 'filter_team'\ndef join_two_queries(first_query, second_query):\n  res = first_query\n  if second_query:\n    if res:\n      res = res & second_query\n    else:\n      res = second_query",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "PARAM_FILTER_TYPE",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "PARAM_FILTER_TYPE = 'filter_type'\nPARAM_FILTER_TEAM = 'filter_team'\ndef join_two_queries(first_query, second_query):\n  res = first_query\n  if second_query:\n    if res:\n      res = res & second_query\n    else:\n      res = second_query\n  return res",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "PARAM_FILTER_TEAM",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "PARAM_FILTER_TEAM = 'filter_team'\ndef join_two_queries(first_query, second_query):\n  res = first_query\n  if second_query:\n    if res:\n      res = res & second_query\n    else:\n      res = second_query\n  return res\ndef filter_patients_by_user(request):",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "FILTER_TYPE_VALUES",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "FILTER_TYPE_VALUES = [\n  'ALL',\n  'FINITION', \n  'IMPRINT',\n]\nfinition_patients_sql = \"\"\"\nSELECT c.* from (\n  SELECT DISTINCT ON (p.id)\n    p.id, t.id AS treatment_id,\n    p.type AS patient_type, ",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "finition_patients_sql",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "finition_patients_sql = \"\"\"\nSELECT c.* from (\n  SELECT DISTINCT ON (p.id)\n    p.id, t.id AS treatment_id,\n    p.type AS patient_type, \n    t.state AS treatment_state, \n    t.updated_at as treatment_updated_at\n  FROM patient AS p\n  INNER JOIN treatment AS t ON (p.id = t.patient_id) and (t.is_finition = TRUE)\n  ORDER BY p.id DESC, t.id DESC",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "imprint_patients_sql",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "imprint_patients_sql = \"\"\"\nSELECT c.* from (\n  SELECT DISTINCT ON (p.id)\n    p.id, t.id AS treatment_id,\n    p.type AS patient_type, \n    t.state AS treatment_state, \n    t.updated_at as treatment_updated_at\n  FROM patient AS p\n  INNER JOIN treatment AS t ON p.id = t.patient_id\n  INNER JOIN prescription AS pr on (t.id = pr.treatment_id) and (pr.clinic_objects ILIKE '%\"impression_type\":\"PHYSICAL_FOOTPRINT\"%')",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "retainer_imprint_patients_sql",
        "kind": 5,
        "importPath": "utils.query_utils",
        "description": "utils.query_utils",
        "peekOfCode": "retainer_imprint_patients_sql = \"\"\"\nSELECT c.* from (\n  SELECT DISTINCT ON (p.id)\n    p.id, \n    p.type AS patient_type, \n    r.id AS retainer_id,\n    r.state AS retainer_state, \n    r.updated_at as retainer_updated_at\n  FROM patient AS p\n  INNER JOIN retainer AS r ON (p.id = r.patient_id) and (r.impression_type ILIKE '%PHYSICAL%')",
        "detail": "utils.query_utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "manage",
        "description": "manage",
        "peekOfCode": "def main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"",
        "detail": "manage",
        "documentation": {}
    }
]